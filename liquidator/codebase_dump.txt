# L2 Micro-Liquidator — Functional Codebase Snapshot

Curated dump of configuration, contracts, TypeScript services, scripts, and tests that power the liquidator. Non-functional artifacts such as logs, build caches, and node_modules are intentionally omitted.

===== BEGIN .env (omitted) =====
# Contents redacted; see local .env for secrets.
===== END .env (omitted) =====

===== BEGIN liquidator/.env.sample =====
# Wallet keys (LOW BALANCE EOAs; sweep daily to Safe)
WALLET_PK_ARB=0x...
WALLET_PK_OP=0x...
WALLET_PK_BASE=0x...

# RPCs
RPC_ARB=https://arb-mainnet.g.alchemy.com/v2/KEY
RPC_OP=https://opt-mainnet.g.alchemy.com/v2/KEY
RPC_BASE=https://base-mainnet.g.alchemy.com/v2/KEY

# Optional RPC fallbacks (latency hedge):
ALT_RPC_ARB=https://arb1.arbitrum.io/rpc
ALT_RPC_OP=https://mainnet.optimism.io
ALT_RPC_BASE=https://mainnet.base.org

# Private-tx relays (optional)
PRIVTX_ARB=<private relay URL>
PRIVTX_OP=<private relay URL>
PRIVTX_BASE=<private relay URL>

# Postgres & Redis
DATABASE_URL=postgres://liquidator:liquidator@localhost:5432/liquidator
REDIS_URL=redis://localhost:6379

# Metrics / Logs
PROM_PORT=9464
LOG_LEVEL=info

# The Graph (Aave v3 subgraphs)
GRAPH_API_KEY=your_graph_api_key
AAVE_V3_SUBGRAPH_ARB=https://gateway.thegraph.com/api/${GRAPH_API_KEY}/subgraphs/id/DLuE98kEb5pQNXAcKFQGQgfSQ57Xdou4jnVbAEqMfy3B
AAVE_V3_SUBGRAPH_OP=https://gateway.thegraph.com/api/${GRAPH_API_KEY}/subgraphs/id/DSfLz8oQBUeU5atALgUFQKMTSYV9mZAVYp4noLSXAfvb
AAVE_V3_SUBGRAPH_BASE=https://gateway.thegraph.com/api/${GRAPH_API_KEY}/subgraphs/id/GQFbb95cE6d8mV989mL5figjaGaKCQB3xqYrr1bRyXqF
AAVE_V3_SUBGRAPH_POLYGON=https://gateway.thegraph.com/api/${GRAPH_API_KEY}/subgraphs/id/<POLYGON_SUBGRAPH_ID>

# Sequencer grace (safety):
SEQUENCER_GRACE_SECS=120

# Analysis
OPENAI_API_KEY=sk-...

===== END liquidator/.env.sample =====

===== BEGIN liquidator/README.md =====
# L2 Micro-Liquidator (Arbitrum & Optimism) — MVP Scaffold

**Purpose**: Liquidate the long-tail of risky loans on Aave v3 using Aave flash liquidity, seize collateral with the protocol bonus, swap, repay flash + premium, keep spread. Designed for cheap L2 gas.

### Quickstart (dev)
1) **Install**
```bash
cd liquidator
npm i
forge install
```
2) **Configure**
- Copy `.env.sample` → `.env` and fill RPCs + private keys.
- Add your The Graph Gateway key (`GRAPH_API_KEY`) and set any `AAVE_V3_SUBGRAPH_*` overrides in `.env` if you use hosted subgraphs.
- Copy `config.example.yaml` → `config.yaml` and review markets.

3) **Compile & test**
```bash
forge build
forge test -vv
```

4) **Deploy Liquidator** (example: Arbitrum)
```bash
forge create --rpc-url $RPC_ARB --private-key $WALLET_PK_ARB contracts/Liquidator.sol:Liquidator \
 --constructor-args $AAVE_POOL_ARB $UNI_V3_ROUTER_ARB $BENEFICIARY
```

5) **Run orchestrator (shadow mode)**
```bash
npm run dev
```

	Or (ensures `${VAR}` interpolation via dotenv-expand without manually sourcing):
```bash
./scripts/dev_env.sh
```

6) **Go live (canary)**: enable 1–2 markets in `config.yaml` with high `minProfit`, tight `slippageBps`, `gapCapBps`.

**Not legal/financial advice. Use at your own risk.**

### Persistent observability
- **File logs**: Runtime logs now mirror to `logs/live.log`. Override with `LOG_DIR`, `LOG_FILE_NAME`, or disable stdout mirroring with `LOG_DISABLE_STDOUT=1`. Rotate/ship this file with your preferred tooling.
- **Attempt store (optional)**: Set `DATABASE_URL` to a Postgres connection string before starting the orchestrator to persist policy skips, dry-runs, and failures. The table is auto-provisioned via `ensureAttemptTable()` on boot.

### Live ops checklist
- **Config**: set `beneficiary` to your Safe, populate `contracts.liquidator[chainId]` after deployment, and verify token/pool/router addresses against Aave & Uniswap docs.
- **Safety**: keep `risk.dryRun: true` for 12–24h canary to observe `would-fire` logs and price gaps before flipping to live.
- **Micro-live guardrails**: before disabling dry-run, set conservative `risk.maxRepayUsd` (per liquidation), `risk.maxSessionNotionalUsd` (rolling session spend), and `risk.maxLiveExecutions` (per process) to cap exposure during canary runs; the orchestrator will exit once any cap is hit.
- **Keys & funding**: export low-balance EOAs via `.env`, fund gas (ARB/OP) just-in-time, sweep proceeds to the Safe frequently.
- **Deployment**: `forge create` with the chain-specific pool/router above and your beneficiary, then record the address back into `config.yaml`.
- **Monitoring**: watch Prometheus gauges (`pnl_per_gas`, `hit_rate`), log-level `debug` for gap skips, and track failed tx hashes for revert reasons.
- **Shadow QA**: use `npm run dev` in dry-run plus `npx ts-node offchain/tools/replay-candidates.ts samples.json --limit 50` to replay captured candidates against live RPCs before flipping `dryRun` off.

===== END liquidator/README.md =====

===== BEGIN liquidator/config.yaml =====
beneficiary: "0x89A6b89718baCdF5D717877ded7E6E12D25479A6"

contracts:
  liquidator:
    42161: "0x727BB7c8C0F1Fc150F6d23Df197e639Af4506d91"
    10: "0xEd4dB6eA97B7F9A877f529db65976702083CA64B"

chains:
  - id: 42161
    name: arbitrum
    rpc: ${RPC_ARB}
    privtx: ${PRIVTX_ARB}
    aaveProvider: "0xa97684EaD0E402dC232d5A977953DF7ECBaB3CDb"
    uniV3Router: "0xE592427A0AEce92De3Edee1F18E0157C05861564"
    quoter: "0x61fFE014bA17989E743c5F6cB21bF9697530B21e"
    sequencerFeed: "0xFdB631F5EE196F0ed6FAa767959853A9F217697D"
    enabled: true
    tokens:
      USDC:
        address: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831"
        decimals: 6
        chainlinkFeed: "0x50834F3163758fcC1Df9973b6e91f0F0F0434aD3"
      WETH:
        address: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1"
        decimals: 18
        chainlinkFeed: "0x639fe6ab55c921f74e7fac1ee960c0b6293ba612"
      USDT:
        address: "0xFd086bC7CD5C481DCC9C85ebe478A1C0b69FCBb9"
        decimals: 6
      DAI:
        address: "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1"
        decimals: 18
      LINK:
        address: "0xf97f4df75117a78c1A5a0DBb814Af92458539fb4"
        decimals: 18
      wstETH:
        address: "0x5979D7b546E38E414F7E9822514be443A4800529"
        decimals: 18
      WBTC:
        address: "0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f"
        decimals: 8

  - id: 10
    name: optimism
    rpc: ${RPC_OP}
    privtx: ${PRIVTX_OP}
    aaveProvider: "0xa97684EaD0E402dC232d5A977953DF7ECBaB3CDb"
    uniV3Router: "0xE592427A0AEce92De3Edee1F18E0157C05861564"
    quoter: "0x61fFE014bA17989E743c5F6cB21bF9697530B21e"
    sequencerFeed: "0x371EAD81c9102C9BF4874A9075FFFf170F2Ee389"
    enabled: true
    tokens:
      USDC:
        address: "0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85"
        decimals: 6
        chainlinkFeed: "0x16a9fBeff8E22B4a348F00fF41B55A0a7f9eE0f3"
      WETH:
        address: "0x4200000000000000000000000000000000000006"
        decimals: 18
        chainlinkFeed: "0x13e3ee699d1909e989722e753853ae30b17e08c5"
      USDT:
        address: "0x94b008aA00579c1307B0EF2c499aD98a8ce58e58"
        decimals: 6
      DAI:
        address: "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1"
        decimals: 18
      sUSD:
        address: "0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9"
        decimals: 18
      LINK:
        address: "0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6"
        decimals: 18
      wstETH:
        address: "0x1F32b1c2345538C0c6F582fCb022739c4A194Ebb"
        decimals: 18
      WBTC:
        address: "0x68f180fcCe6836688e9084f035309E29Bf0A2095"
        decimals: 8
      LUSD:
        address: "0x93b346b6A35B501801CcF6AdFe9828bCaa54e721"
        decimals: 18
      rETH:
        address: "0xEC70Dcb5F5343a5fDd4dB57B78F98598F3591111"
        decimals: 18
      OP:
        address: "0x4200000000000000000000000000000000000042"
        decimals: 18

  - id: 8453
    name: base
    rpc: ${RPC_BASE}
    privtx: ${PRIVTX_BASE}
    aaveProvider: ${BASE_AAVE_V3_PROVIDER}
    uniV3Router: "0x2626664c2603336E57B271c5C0b26F421741e481"
    quoter: "0x3d4e44Eb1374240CE5F1B871ab261CD16335B76a"
    sequencerFeed: "0xBCF85224fc0756B9Fa45aA7892530B47e10b6433"
    enabled: false
    tokens:
      USDC:
        address: "0x833589fcd6EDB6E08f4c7C32D4f71B54bDa02913"
        decimals: 6
        chainlinkFeed: "0x7e860098F58bBFC8648a4311b374B1D669a2bc6B"
      WETH:
        address: "0x4200000000000000000000000000000000000006"
        decimals: 18
        chainlinkFeed: "0x71041dddad3595F9CEd3DcCFBe3D1F4b0a16Bb70"

  - id: 137
    name: polygon
    rpc: ${RPC_POLYGON}
    privtx: ${PRIVTX_POLYGON}
    aaveProvider: "0xa97684EaD0E402dC232d5A977953DF7ECBaB3CDb"
    uniV3Router: "0xe592427a0aece92de3edee1f18e0157c05861564"
    quoter: "0x61ffe014ba17989e743c5f6cb21bf9697530b21e"
    enabled: false
    tokens:
      USDC:
        address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
        decimals: 6
        chainlinkFeed: "0xfE4A8cc5b5B2366C1B58Bea3858e81843581b2F7"
      WETH:
        address: "0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619"
        decimals: 18
        chainlinkFeed: "0xF9680D99D6C9589e2a93a78A04A279e509205945"

assets:
  USDC:
    floorBps: 30
    gapCapBps: 50
    slippageBps: 50
  WETH:
    floorBps: 30
    gapCapBps: 60
    slippageBps: 30
  USDT:
    floorBps: 30
    gapCapBps: 50
    slippageBps: 60
  DAI:
    floorBps: 30
    gapCapBps: 50
    slippageBps: 50
  sUSD:
    floorBps: 30
    gapCapBps: 50
    slippageBps: 50
  LINK:
    floorBps: 40
    gapCapBps: 80
    slippageBps: 30
  wstETH:
    floorBps: 30
    gapCapBps: 70
    slippageBps: 30
  WBTC:
    floorBps: 50
    gapCapBps: 100
    slippageBps: 40
  LUSD:
    floorBps: 30
    gapCapBps: 50
    slippageBps: 50
  rETH:
    floorBps: 30
    gapCapBps: 70
    slippageBps: 30
  OP:
    floorBps: 40
    gapCapBps: 90
    slippageBps: 40

markets:
  - protocol: aavev3
    chainId: 42161
    debtAsset: USDC
    collateralAsset: WETH
    closeFactorBps: 5000
    bonusBps: 800
    enabled: true

  - protocol: aavev3
    chainId: 10
    debtAsset: USDC
    collateralAsset: WETH
    closeFactorBps: 5000
    bonusBps: 800
    enabled: true

  - protocol: aavev3
    chainId: 8453
    debtAsset: USDC
    collateralAsset: WETH
    closeFactorBps: 5000
    bonusBps: 800
    enabled: false

  - protocol: aavev3
    chainId: 137
    debtAsset: USDC
    collateralAsset: WETH
    closeFactorBps: 5000
    bonusBps: 800
    enabled: false

risk:
  gasCapUsd: 8.0
  failRateCap: 0.25
  pnlPerGasMin: 2.5
  maxAttemptsPerBorrowerHour: 6
  dryRun: false
  healthFactorMax: 0.96
  maxRepayUsd: 500
  maxLiveExecutions: 50
  maxSessionNotionalUsd: 2000
  denyAssets: ["MAI"]
indexer:
  subgraphFirst: 1000
  dedupeMs: 60000
  pollMs: 200
  hfThreshold: 1.05

routing:
  prefer:
    42161:
      USDC-WETH: ["UniV3:500","UniV3:3000","Camelot"]
      LINK-USDC: ["UniV3:3000","UniV3:500"]
      wstETH-WETH: ["UniV3:500"]
      WBTC-USDC: ["UniV3:3000","UniV3:500"]
    10:
      USDC-WETH: ["UniV3:500","UniV3:3000","Velodrome"]
      sUSD-USDC: ["Velodrome"]
      LINK-USDC: ["UniV3:3000","UniV3:500"]
      wstETH-WETH: ["Velodrome","UniV3:500"]
      WBTC-USDC: ["Velodrome","UniV3:3000"]
      LUSD-USDC: ["Velodrome","UniV3:500"]
      rETH-WETH: ["Velodrome","UniV3:500"]
      OP-USDC: ["Velodrome","UniV3:3000","UniV3:500"]
    8453:
      USDC-WETH: ["UniV3:500","UniV3:3000","Aerodrome"]
      wstETH-WETH: ["UniV3:500"]
    137:
      USDC-WETH: ["UniV3:500","UniV3:3000"]

dexRouters:
  42161:
    uniV3: "0xE592427A0AEce92De3Edee1F18E0157C05861564"
    camelotV2: "0xc873fEcbd354f5A56E00E710B90EF4201db2448d"
    tokens:
      USDC: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831"
      WETH: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1"

  10:
    uniV3: "0xE592427A0AEce92De3Edee1F18E0157C05861564"
    velodrome: "0xa062aE8A9c5e11aaA026fc2670B0D65cCc8B2858"
    velodromeFactory: "0xF1046053aa5682b4F9a81b5481394DA16BE5FF5a"
    tokens:
      USDC: "0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85"
      WETH: "0x4200000000000000000000000000000000000006"

  8453:
    uniV3: "0x2626664c2603336E57B271c5C0b26F421741e481"
    aerodrome: "0xcF77A3bA9A5cA399B7c97C74D54e5B1bEb874E43"
    aerodromeFactory: "0x420DD381b31aEf6683db6B902084cB0FFECe40Da"
    tokens:
      USDC: "0x833589fcd6EDB6E08f4c7C32D4f71B54bDa02913"
      WETH: "0x4200000000000000000000000000000000000006"

  137:
    uniV3: "0xE592427A0AEce92De3Edee1F18E0157C05861564"
    tokens:
      USDC: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
      WETH: "0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619"

===== END liquidator/config.yaml =====

===== BEGIN liquidator/config.example.yaml =====
contracts:
  liquidator:
    42161: "0x..."
    10: "0x..."

chains:
  - id: 42161   # Arbitrum
    name: arbitrum
    rpc: ${RPC_ARB}
    privtx: ${PRIVTX_ARB}
    aaveProvider: "0xa97684EaD0E402dC232d5A977953DF7ECBaB3CDb"  # PoolAddressesProvider
    uniV3Router: "0x..."     # Uniswap V3 Router02
    quoter: "0x..."          # Uniswap V3 Quoter V2
    enabled: true
    tokens:
      USDC:
        address: "0x..."
        decimals: 6
        chainlinkFeed: "0x..." # optional
      WETH:
        address: "0x..."
        decimals: 18
        chainlinkFeed: "0x..."
  - id: 10      # Optimism
    name: optimism
    rpc: ${RPC_OP}
    privtx: ${PRIVTX_OP}
    aaveProvider: "0xa97684EaD0E402dC232d5A977953DF7ECBaB3CDb"
    uniV3Router: "0x..."
    quoter: "0x..."
    enabled: false
    tokens:
      USDC:
        address: "0x..."
        decimals: 6
      WETH:
        address: "0x..."
        decimals: 18
        chainlinkFeed: "0x..."

assets:
  USDC:
    floorBps: 80
    gapCapBps: 40
    slippageBps: 20
  WETH:
    floorBps: 120
    gapCapBps: 60
    slippageBps: 25

markets:
  - protocol: aavev3
    chainId: 42161
    debtAsset: USDC
    collateralAsset: WETH
    closeFactorBps: 4850
    bonusBps: 800
    enabled: true
  - protocol: aavev3
    chainId: 10
    debtAsset: USDC
    collateralAsset: WETH
    closeFactorBps: 4850
    bonusBps: 800
    enabled: false

risk:
  gasCapUsd: 8.0
  failRateCap: 0.25
  pnlPerGasMin: 2.5
  maxAttemptsPerBorrowerHour: 6
  dryRun: false
  healthFactorMax: 0.96
  maxRepayUsd: 500.0
  maxLiveExecutions: 50
  maxSessionNotionalUsd: 2000.0
  denyAssets: []

indexer:
  subgraphFirst: 1000
  dedupeMs: 60000
  pollMs: 200
  hfThreshold: 1.05

analysis:
  openaiKey: ${OPENAI_API_KEY}

dexRouters:
  42161:
    uniV3: "0xE592427A0AEce92De3Edee1F18E0157C05861564"
    camelotV2: "0xc873fEcbd354f5A56E00E710B90EF4201db2448d"
    tokens:
      USDC: "0xaf88d065e77c8cC2239327c5EdB3A432268e5831"
      WETH: "0x82Af49447D8a07e3Bd95BD0d56F35241523fBaB1"
  10:
    uniV3: "0xE592427A0AEce92De3Edee1F18E0157C05861564"
    velodrome: "0xa062aE8A9c5e11aaA026fc2670B0D65cCc8B2858"
    velodromeFactory: "0xF1046053aa5682b4F9a81b5481394DA16BE5FF5a"
    tokens:
      USDC: "0x0B2c639c533813f4aa9d7837cAf62653d097Ff85"
      WETH: "0x4200000000000000000000000000000000000006"
  8453:
    uniV3: "0x2626664c2603336E57B271c5C0b26F421741e481"
    aerodrome: "0xcF77A3bA9A5cA399B7c97C74D54e5B1bEb874e43"
    aerodromeFactory: "0x420DD381b31aEf6683db6B902084cB0FFECe40Da"
    tokens:
      USDC: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
      WETH: "0x4200000000000000000000000000000000000006"
  137:
    uniV3: "0xE592427A0AEce92De3Edee1F18E0157C05861564"
    tokens:
      USDC: "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359"
      WETH: "0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619"
  - id: 8453    # Base (optional)
    name: base
    rpc: ${RPC_BASE}
    privtx: ${PRIVTX_BASE}
    aaveProvider: "TODO_AAVE_V3_PROVIDER_BASE"
    uniV3Router: "0x2626664c2603336E57B271c5C0b26F421741e481"  # SwapRouter02
    quoter: "0x3d4e44Eb1374240CE5F1B871ab261CD16335B76a"
    enabled: false
    tokens:
      USDC:
        address: "0x833589fcd6EDB6E08f4c7C32D4f71B54bDa02913"
        decimals: 6
      WETH:
        address: "0x4200000000000000000000000000000000000006"
        decimals: 18

  - id: 137     # Polygon PoS (optional)
    name: polygon
    rpc: ${RPC_POLYGON}
    privtx: ${PRIVTX_POLYGON}
    aaveProvider: "0xa97684EaD0E402dC232d5A977953DF7ECBaB3CDb"
    uniV3Router: "0xE592427A0AEce92De3Edee1F18E0157C05861564"
    quoter: "0x61ffe014ba17989e743c5f6cb21bf9697530b21e"
    enabled: false
    tokens:
      USDC:
        address: "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359"
        decimals: 6
      WETH:
        address: "0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619"
        decimals: 18

===== END liquidator/config.example.yaml =====

===== BEGIN liquidator/docker-compose.yml =====
version: '3.8'
services:
  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: liquidator
      POSTGRES_PASSWORD: liquidator
      POSTGRES_DB: liquidator
    ports: ["5432:5432"]
  redis:
    image: redis:7-alpine
    ports: ["6379:6379"]
  worker:
    build: ./ops
    env_file:
      - .env
    command: ["node","/app/dist/offchain/orchestrator.js"]
    depends_on: [db, redis]

===== END liquidator/docker-compose.yml =====

===== BEGIN liquidator/package.json =====
{
  "name": "l2-micro-liquidator",
  "private": true,
  "version": "1.0.0",
  "scripts": {
    "dev": "ts-node --transpile-only offchain/orchestrator.ts",
    "build": "tsc -p .",
    "lint": "eslint . --ext .ts",
    "feed:check": "ts-node --transpile-only offchain/tools/feed-check.ts",
    "quote:check": "ts-node --transpile-only offchain/tools/quote-check.ts",
    "replay": "ts-node --transpile-only offchain/tools/replay-candidates.ts",
    "subgraph:check": "ts-node --transpile-only offchain/tools/subgraph_check.ts",
    "preflight": "ts-node --transpile-only offchain/tools/preflight.ts"
  },
  "dependencies": {
    "dotenv": "^16.4.5",
    "dotenv-expand": "^12.0.3",
    "fastify": "^4.28.1",
    "ioredis": "^5.4.1",
    "openai": "^4.57.0",
    "pg": "^8.12.0",
    "pino": "^9.2.0",
    "prom-client": "^15.1.1",
    "viem": "^2.13.6",
    "yaml": "^2.5.1",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@types/node": "^20.14.10",
    "@types/pg": "^8.10.2",
    "@typescript-eslint/eslint-plugin": "^8.45.0",
    "@typescript-eslint/parser": "^8.45.0",
    "eslint": "^9.36.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.6.2",
    "typescript-eslint": "^8.45.0"
  }
}

===== END liquidator/package.json =====

===== BEGIN liquidator/tsconfig.json =====
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "strict": true,
    "esModuleInterop": true,
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "allowJs": false,
    "rootDir": ".",
    "outDir": "dist",
    "declaration": false,
    "skipLibCheck": true
  },
  "include": ["offchain/**/*.ts", "scripts/**/*.ts", "types/**/*.d.ts"]
}

===== END liquidator/tsconfig.json =====

===== BEGIN liquidator/eslint.config.js =====
const globals = require("globals");
const tseslint = require("typescript-eslint");

module.exports = [
  {
    // Global ignores for compiled output, node modules, and all JS files.
    ignores: ["dist/", "node_modules/", "**/*.js"],
  },
  // Base TypeScript configuration
  ...tseslint.configs.recommended,
  {
    // Custom rules for TypeScript files
    files: ["**/*.ts"],
    rules: {
      "prefer-const": "off", // Disabled due to false positives in orchestrator.ts after refactoring
      "@typescript-eslint/no-explicit-any": "off",
      "@typescript-eslint/no-unused-vars": "warn",
    },
  },
];

===== END liquidator/eslint.config.js =====

===== BEGIN liquidator/foundry.toml =====
[profile.default]
src = 'contracts'
out = 'out'
libs = ['lib']
test = 'tests/foundry'
compiler_version = '0.8.24'
via-ir = true
optimizer = true
optimizer_runs = 999999

===== END liquidator/foundry.toml =====

===== BEGIN liquidator/foundry.lock =====
{
  "lib/forge-std": {
    "tag": {
      "name": "v1.9.5",
      "rev": "b93cf4bc34ff214c099dc970b153f85ade8c9f66"
    }
  }
}
===== END liquidator/foundry.lock =====

===== BEGIN liquidator/ops/Dockerfile =====
FROM node:20-alpine as builder
WORKDIR /app
COPY package.json package-lock.json* ./
RUN npm ci --omit=dev
COPY offchain ./offchain
COPY config.example.yaml ./config.example.yaml
RUN npm run build || true

FROM node:20-alpine
WORKDIR /app
COPY --from=builder /app /app
CMD ["node","/app/dist/offchain/orchestrator.js"]

===== END liquidator/ops/Dockerfile =====

===== BEGIN liquidator/contracts/Liquidator.sol =====
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {IERC20} from "./interfaces/IERC20.sol";
import {IAaveV3Pool} from "./interfaces/IAaveV3Pool.sol";
import {IFlashLoanSimpleReceiver} from "./interfaces/IFlashLoanSimpleReceiver.sol";
import {ISwapRouterV3} from "./interfaces/ISwapRouterV3.sol";
import {IUniswapV2Router02} from "./interfaces/IUniswapV2Router.sol";
import {ISolidlyRouterV2} from "./interfaces/ISolidlyRouterV2.sol";
import {DexRouter} from "./libs/DexRouter.sol";
import {IPoolAddressesProvider} from "./interfaces/IPoolAddressesProvider.sol";

/// @title L2 Micro-Liquidator (Aave v3 + UniV3)
/// @notice Minimal flash-loan liquidator with on-chain minProfit & slippage guards
contract Liquidator is IFlashLoanSimpleReceiver {
    address public owner;
    bool public paused;

    IPoolAddressesProvider public immutable PROVIDER;
    ISwapRouterV3 public immutable ROUTER;
    address public beneficiary; // profits forwarded here

    mapping(address => bool) public allowedRouters;

    struct Plan {
        address borrower;
        address debtAsset;
        address collateralAsset;
        uint256 repayAmount;       // amount of debt to repay with flash or inventory
        uint8 dexId;               // 0=UniV3, 1=SolidlyV2, 2=UniV2, 3=UniV3Multi
        address router;            // swap router to use
        uint24 uniFee;             // UniV3 pool fee (first hop for multi)
        bool solidlyStable;        // Solidly route flag
        address solidlyFactory;    // Solidly factory for the pair
        uint256 minProfit;         // in debtAsset units
        uint256 amountOutMin;      // slippage guard for collateral->debt swap
        uint256 deadline;          // swap deadline
        bytes path;                // optional encoded UniV3 multi-hop path
    }

    Plan private current;

    modifier onlyOwner() { require(msg.sender == owner, "!owner"); _; }

    event Fired(address indexed borrower, address debtAsset, address collateralAsset, uint256 repayAmount);
    event Profit(address indexed asset, uint256 netProfit);
    event Paused(bool status);
    event BeneficiaryChanged(address who);
    event RouterAllowed(address router, bool allowed);

    constructor(address aaveProvider, address uniRouter, address _beneficiary) {
        owner = msg.sender;
        PROVIDER = IPoolAddressesProvider(aaveProvider);
        ROUTER = ISwapRouterV3(uniRouter);
        beneficiary = _beneficiary;
        allowedRouters[uniRouter] = true;
    }

    function setPaused(bool p) external onlyOwner { paused = p; emit Paused(p); }
    function setBeneficiary(address b) external onlyOwner { beneficiary = b; emit BeneficiaryChanged(b); }
    function setRouterAllowed(address r, bool a) external onlyOwner {
        allowedRouters[r] = a;
        emit RouterAllowed(r, a);
    }

    /// @notice Offchain bot calls this to initiate a liquidation via Aave flash loan
    function liquidateWithFlash(Plan calldata p) external onlyOwner {
        require(!paused, "paused");
        require(p.repayAmount > 0 && p.minProfit > 0, "bad plan");
        require(allowedRouters[p.router], "router !allowed");
        current = p; // store for callback
        emit Fired(p.borrower, p.debtAsset, p.collateralAsset, p.repayAmount);
        _pool().flashLoanSimple(address(this), p.debtAsset, p.repayAmount, abi.encode(p), 0);
    }

    /// @dev Aave flash loan callback
    function executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        address /*initiator*/,
        bytes calldata params
    ) external override returns (bool) {
        IAaveV3Pool pool = _pool();
        require(msg.sender == address(pool), "only pool");
        Plan memory p = abi.decode(params, (Plan));
        // Safety: ensure callback matches requested asset/amount
        require(asset == p.debtAsset && amount == p.repayAmount, "mismatch");

        // Approve debt to pool for liquidation call
        _approveMax(p.debtAsset, address(pool), amount);
        // Perform liquidation (receive collateral)
        pool.liquidationCall(p.collateralAsset, p.debtAsset, p.borrower, amount, false);

        uint256 profit = _finalizeFlash(p, pool, amount, premium);
        emit Profit(p.debtAsset, profit);
        return true;
    }

    /// @notice Liquidate using inventory funds held by the contract (no flash loan)
    function liquidateWithFunds(Plan calldata p) external onlyOwner {
        require(!paused, "paused");
        require(p.repayAmount > 0 && p.minProfit > 0, "bad plan");
        require(allowedRouters[p.router], "router !allowed");
        uint256 bal = IERC20(p.debtAsset).balanceOf(address(this));
        require(bal >= p.repayAmount, "funds low");

        IAaveV3Pool pool = _pool();
        _approveMax(p.debtAsset, address(pool), p.repayAmount);
        pool.liquidationCall(p.collateralAsset, p.debtAsset, p.borrower, p.repayAmount, false);

        uint256 profit = _finalizeFunds(p, p.repayAmount);
        emit Profit(p.debtAsset, profit);
    }

    function _finalizeFlash(Plan memory p, IAaveV3Pool pool, uint256 amount, uint256 premium) internal returns (uint256) {
        uint256 out = _swapCollateralForDebt(p);
        uint256 owe = amount + premium;
        require(out >= owe, "insufficient out");
        _approveMax(p.debtAsset, address(pool), owe);

        uint256 profit = out - owe;
        require(profit >= p.minProfit, "minProfit not met");

        bool ok = IERC20(p.debtAsset).transfer(beneficiary, profit);
        require(ok, "profit transfer failed");
        return profit;
    }

    function _finalizeFunds(Plan memory p, uint256 spent) internal returns (uint256) {
        uint256 out = _swapCollateralForDebt(p);
        require(out >= spent, "insufficient out");

        uint256 profit = out - spent;
        require(profit >= p.minProfit, "minProfit not met");

        if (profit > 0) {
            bool ok = IERC20(p.debtAsset).transfer(beneficiary, profit);
            require(ok, "profit transfer failed");
        }
        return profit;
    }

    function _swapCollateralForDebt(Plan memory p) internal returns (uint256 out) {
        uint256 collBal = IERC20(p.collateralAsset).balanceOf(address(this));
        require(collBal > 0, "no collateral");
        if (p.dexId == uint8(DexRouter.Dex.UniV3)) {
            out = DexRouter.swapUniV3(
                ISwapRouterV3(p.router),
                p.collateralAsset,
                p.debtAsset,
                p.uniFee,
                collBal,
                p.amountOutMin,
                p.deadline
            );
        } else if (p.dexId == uint8(DexRouter.Dex.SolidlyV2)) {
            out = DexRouter.swapSolidlyV2(
                ISolidlyRouterV2(p.router),
                p.collateralAsset,
                p.debtAsset,
                p.solidlyStable,
                p.solidlyFactory,
                collBal,
                p.amountOutMin,
                p.deadline
            );
        } else if (p.dexId == uint8(DexRouter.Dex.UniV2)) {
            out = DexRouter.swapUniV2(
                IUniswapV2Router02(p.router),
                p.collateralAsset,
                p.debtAsset,
                collBal,
                p.amountOutMin,
                p.deadline
            );
        } else if (p.dexId == uint8(DexRouter.Dex.UniV3Multi)) {
            out = DexRouter.swapUniV3Multi(
                ISwapRouterV3(p.router),
                p.path,
                collBal,
                p.amountOutMin,
                p.deadline
            );
        } else {
            revert("dexId");
        }
    }

    function _approveMax(address token, address spender, uint256 needed) internal {
        if (IERC20(token).allowance(address(this), spender) < needed) {
            IERC20(token).approve(spender, type(uint256).max);
        }
    }

    function _pool() internal view returns (IAaveV3Pool) {
        return IAaveV3Pool(PROVIDER.getPool());
    }
}

===== END liquidator/contracts/Liquidator.sol =====

===== BEGIN liquidator/contracts/libs/DexRouter.sol =====
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {ISwapRouterV3} from "../interfaces/ISwapRouterV3.sol";
import {IUniswapV2Router02} from "../interfaces/IUniswapV2Router.sol";
import {ISolidlyRouterV2} from "../interfaces/ISolidlyRouterV2.sol";
import {IERC20} from "../interfaces/IERC20.sol";

library DexRouter {
    enum Dex {
        UniV3,
        SolidlyV2,
        UniV2,
        UniV3Multi
    }

    function _approve(address token, address spender, uint256 amount) private {
        if (IERC20(token).allowance(address(this), spender) < amount) {
            IERC20(token).approve(spender, type(uint256).max);
        }
    }

    function swapUniV3(
        ISwapRouterV3 router,
        address tokenIn,
        address tokenOut,
        uint24 fee,
        uint256 amountIn,
        uint256 amountOutMin,
        uint256 deadline
    ) internal returns (uint256 out) {
        _approve(tokenIn, address(router), amountIn);
        out = router.exactInputSingle(
            ISwapRouterV3.ExactInputSingleParams({
                tokenIn: tokenIn,
                tokenOut: tokenOut,
                fee: fee,
                recipient: address(this),
                deadline: deadline,
                amountIn: amountIn,
                amountOutMinimum: amountOutMin,
                sqrtPriceLimitX96: 0
            })
        );
    }

    function swapUniV3Multi(
        ISwapRouterV3 router,
        bytes memory path,
        uint256 amountIn,
        uint256 amountOutMin,
        uint256 deadline
    ) internal returns (uint256 out) {
        require(path.length >= 43, "path short");
        address tokenIn;
        assembly {
            tokenIn := shr(96, mload(add(path, 32)))
        }
        _approve(tokenIn, address(router), amountIn);
        out = router.exactInput(
            ISwapRouterV3.ExactInputParams({
                path: path,
                recipient: address(this),
                deadline: deadline,
                amountIn: amountIn,
                amountOutMinimum: amountOutMin
            })
        );
    }

    function swapSolidlyV2(
        ISolidlyRouterV2 router,
        address tokenIn,
        address tokenOut,
        bool stable,
        address factory,
        uint256 amountIn,
        uint256 amountOutMin,
        uint256 deadline
    ) internal returns (uint256 out) {
        _approve(tokenIn, address(router), amountIn);
        ISolidlyRouterV2.Route[] memory routes = new ISolidlyRouterV2.Route[](1);
        routes[0] = ISolidlyRouterV2.Route({from: tokenIn, to: tokenOut, stable: stable, factory: factory});
        uint256[] memory amounts = router.swapExactTokensForTokens(amountIn, amountOutMin, routes, address(this), deadline);
        out = amounts[amounts.length - 1];
    }

    function swapUniV2(
        IUniswapV2Router02 router,
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 amountOutMin,
        uint256 deadline
    ) internal returns (uint256 out) {
        _approve(tokenIn, address(router), amountIn);
        address[] memory path = new address[](2);
        path[0] = tokenIn;
        path[1] = tokenOut;
        uint256[] memory amounts = router.swapExactTokensForTokens(amountIn, amountOutMin, path, address(this), deadline);
        out = amounts[amounts.length - 1];
    }
}

===== END liquidator/contracts/libs/DexRouter.sol =====

===== BEGIN liquidator/contracts/interfaces/IAaveV3Pool.sol =====
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IAaveV3Pool {
    function liquidationCall(
        address collateralAsset,
        address debtAsset,
        address user,
        uint256 debtToCover,
        bool receiveAToken
    ) external;

    function flashLoanSimple(
        address receiverAddress,
        address asset,
        uint256 amount,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

===== END liquidator/contracts/interfaces/IAaveV3Pool.sol =====

===== BEGIN liquidator/contracts/interfaces/IERC20.sol =====
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function decimals() external view returns (uint8);
}

===== END liquidator/contracts/interfaces/IERC20.sol =====

===== BEGIN liquidator/contracts/interfaces/IFlashLoanSimpleReceiver.sol =====
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IFlashLoanSimpleReceiver {
    function executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        address initiator,
        bytes calldata params
    ) external returns (bool);
}

===== END liquidator/contracts/interfaces/IFlashLoanSimpleReceiver.sol =====

===== BEGIN liquidator/contracts/interfaces/IPoolAddressesProvider.sol =====
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IPoolAddressesProvider {
    function getPool() external view returns (address);
}

===== END liquidator/contracts/interfaces/IPoolAddressesProvider.sol =====

===== BEGIN liquidator/contracts/interfaces/ISolidlyRouterV2.sol =====
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface ISolidlyRouterV2 {
    struct Route {
        address from;
        address to;
        bool stable;
        address factory;
    }

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        Route[] calldata routes,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function getAmountsOut(uint256 amountIn, Route[] calldata routes) external view returns (uint256[] memory amounts);
}

===== END liquidator/contracts/interfaces/ISolidlyRouterV2.sol =====

===== BEGIN liquidator/contracts/interfaces/ISwapRouterV3.sol =====
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface ISwapRouterV3 {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    struct ExactInputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
    }

    function exactInputSingle(ExactInputSingleParams calldata params)
        external
        payable
        returns (uint256 amountOut);

    function exactInput(ExactInputParams calldata params)
        external
        payable
        returns (uint256 amountOut);
}

===== END liquidator/contracts/interfaces/ISwapRouterV3.sol =====

===== BEGIN liquidator/contracts/interfaces/IUniswapV2Router.sol =====
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IUniswapV2Router02 {
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);
}

===== END liquidator/contracts/interfaces/IUniswapV2Router.sol =====

===== BEGIN liquidator/script/AllowRouters.s.sol =====
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Script.sol";
import {Liquidator} from "../contracts/Liquidator.sol";

contract AllowRouters is Script {
    function run() external {
        address liq = vm.envAddress("LIQUIDATOR");
        address[] memory routers = new address[](5);
        uint256 n;
        // Required
        address uni = vm.envOr("UNIV3_ROUTER", address(0));
        if (uni != address(0)) { routers[n++] = uni; }
        // Optional secondaries
        address v = vm.envOr("SECONDARY_ROUTER1", address(0));
        if (v != address(0)) { routers[n++] = v; }
        address v2 = vm.envOr("SECONDARY_ROUTER2", address(0));
        if (v2 != address(0)) { routers[n++] = v2; }
        address v3 = vm.envOr("SECONDARY_ROUTER3", address(0));
        if (v3 != address(0)) { routers[n++] = v3; }
        address v4 = vm.envOr("SECONDARY_ROUTER4", address(0));
        if (v4 != address(0)) { routers[n++] = v4; }

        vm.startBroadcast();
        for (uint256 i = 0; i < n; i++) {
            Liquidator(liq).setRouterAllowed(routers[i], true);
        }
        vm.stopBroadcast();
    }
}

===== END liquidator/script/AllowRouters.s.sol =====

===== BEGIN liquidator/script/Deploy.s.sol =====
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Script.sol";
import {Liquidator} from "../contracts/Liquidator.sol";

contract Deploy is Script {
    function run() external {
        address provider = vm.envAddress("AAVE_V3_PROVIDER");
        address uniRouter = vm.envAddress("UNIV3_ROUTER");
        address beneficiary = vm.envAddress("BENEFICIARY");
        vm.startBroadcast();
        Liquidator liq = new Liquidator(provider, uniRouter, beneficiary);
        vm.stopBroadcast();
        console2.log("Liquidator:", address(liq));
    }
}

===== END liquidator/script/Deploy.s.sol =====

===== BEGIN liquidator/scripts/allow_routers.sh =====
#!/usr/bin/env bash
set -euo pipefail

# Allow-list routers for a given chain (arb|op)
# Requires .env and LIQUIDATOR address exported or provided via --liquidator

usage() { echo "Usage: $0 <arb|op> --liquidator 0x..." >&2; exit 1; }

if [ $# -lt 2 ]; then usage; fi

CHAIN="$1"; shift
LIQ=""
while [ $# -gt 0 ]; do
  case "$1" in
    --liquidator)
      LIQ="$2"; shift 2 ;;
    *) usage ;;
  esac
done

if [ -z "$LIQ" ]; then usage; fi

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
set -a
if [ -f "$ROOT_DIR/.env" ]; then source "$ROOT_DIR/.env"; fi
set +a

case "$CHAIN" in
  arb)
    RPC="${RPC_ARB:-}"
    PRIVATE_KEY_VAL="${WALLET_PK_ARB:-}"
    export UNIV3_ROUTER="${ARB_UNIV3_ROUTER:-}"
    export SECONDARY_ROUTER1="${ARB_CAMELOT_ROUTER:-}"
    ;;
  op)
    RPC="${RPC_OP:-}"
    PRIVATE_KEY_VAL="${WALLET_PK_OP:-}"
    export UNIV3_ROUTER="${OP_UNIV3_ROUTER:-}"
    export SECONDARY_ROUTER1="${OP_VELODROME_ROUTER:-}"
    ;;
  *) echo "Unsupported chain: $CHAIN (use arb|op)" >&2; exit 1 ;;
esac

export LIQUIDATOR="$LIQ"

if [ -z "${RPC}" ] || [ -z "${PRIVATE_KEY_VAL}" ] || [ -z "${UNIV3_ROUTER}" ]; then
  echo "Missing required env. Need RPC, WALLET_PK_*, UNIV3_ROUTER" >&2
  exit 2
fi

export PRIVATE_KEY="$PRIVATE_KEY_VAL"

pushd "$ROOT_DIR" >/dev/null
forge script script/AllowRouters.s.sol:AllowRouters \
  --rpc-url "$RPC" \
  --private-key "$PRIVATE_KEY" \
  --broadcast -vvv | tee /tmp/allow_routers_"$CHAIN".log
echo "Routers allowed on $CHAIN for $LIQ"
popd >/dev/null

===== END liquidator/scripts/allow_routers.sh =====

===== BEGIN liquidator/scripts/deploy.sh =====
#!/usr/bin/env bash
set -euo pipefail

# Deploy Liquidator for a given chain (arb|op)
# Requires .env with RPC_*, WALLET_PK_*, *_AAVE_V3_PROVIDER, *_UNIV3_ROUTER, BENEFICIARY

if [ $# -ne 1 ]; then
  echo "Usage: $0 <arb|op>" >&2
  exit 1
fi

CHAIN="$1"
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

set -a
if [ -f "$ROOT_DIR/.env" ]; then source "$ROOT_DIR/.env"; fi
set +a

case "$CHAIN" in
  arb)
    RPC="${RPC_ARB:-}"
    PRIVATE_KEY_VAL="${WALLET_PK_ARB:-}"
    export AAVE_V3_PROVIDER="${ARB_AAVE_V3_PROVIDER:-}"
    export UNIV3_ROUTER="${ARB_UNIV3_ROUTER:-}"
    ;;
  op)
    RPC="${RPC_OP:-}"
    PRIVATE_KEY_VAL="${WALLET_PK_OP:-}"
    export AAVE_V3_PROVIDER="${OP_AAVE_V3_PROVIDER:-}"
    export UNIV3_ROUTER="${OP_UNIV3_ROUTER:-}"
    ;;
  *)
    echo "Unsupported chain: $CHAIN (use arb|op)" >&2
    exit 1
    ;;
esac

export BENEFICIARY="${BENEFICIARY:-}"

if [ -z "${RPC}" ] || [ -z "${PRIVATE_KEY_VAL}" ] || [ -z "${AAVE_V3_PROVIDER}" ] || [ -z "${UNIV3_ROUTER}" ] || [ -z "${BENEFICIARY}" ]; then
  echo "Missing required env. Need RPC, WALLET_PK_*, *AAVE_V3_PROVIDER, *UNIV3_ROUTER, BENEFICIARY" >&2
  exit 2
fi

export PRIVATE_KEY="$PRIVATE_KEY_VAL"

pushd "$ROOT_DIR" >/dev/null
forge script script/Deploy.s.sol:Deploy \
  --rpc-url "$RPC" \
  --private-key "$PRIVATE_KEY" \
  --broadcast -vvv | tee /tmp/deploy_"$CHAIN".log

ADDR=$(grep -Eo 'Liquidator:\s*0x[0-9a-fA-F]{40}' /tmp/deploy_"$CHAIN".log | awk '{print $2}' | tail -n1 || true)
if [ -n "$ADDR" ]; then
  echo "Deployed Liquidator on $CHAIN: $ADDR"
else
  echo "Deployed, but could not parse address from logs. Check /tmp/deploy_${CHAIN}.log" >&2
fi
popd >/dev/null

===== END liquidator/scripts/deploy.sh =====

===== BEGIN liquidator/scripts/dev_env.sh =====
#!/usr/bin/env bash
set -euo pipefail
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT="${SCRIPT_DIR}/.."
# Prefer liquidator/.env then repo root .env
if [[ -f "${ROOT}/.env" ]]; then
  set -a; source "${ROOT}/.env"; set +a
elif [[ -f "${ROOT}/../.env" ]]; then
  set -a; source "${ROOT}/../.env"; set +a
fi
exec npm run dev

===== END liquidator/scripts/dev_env.sh =====

===== BEGIN liquidator/scripts/dry_run_12h.sh =====
#!/usr/bin/env bash
set -u -o pipefail
# Note: we intentionally do NOT use 'set -e' for this wrapper so orchestrator crashes don't kill the 12h loop.

# 12 hour dry-run wrapper that ensures dryRun stays enabled and captures logs with rotation
DURATION_SECONDS=$((12*60*60))
START_TS=$(date +%s)
END_TS=$((START_TS + DURATION_SECONDS))

REPO_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")"/.. && pwd)"
LOG_DIR="${REPO_ROOT}/logs"
mkdir -p "$LOG_DIR"
LOG_FILE_BASE="${LOG_DIR}/dryrun_$(date -u +%Y%m%dT%H%M%SZ)"
MAIN_LOG="${LOG_FILE_BASE}.log"
JSON_LOG="${LOG_FILE_BASE}.jsonl"
PID_FILE="${LOG_FILE_BASE}.pid"

# Safety check: refuse to run if config has dryRun: false
if ! grep -qE 'dryRun:\s*true' "${REPO_ROOT}/config.yaml"; then
  echo "[FATAL] config.yaml risk.dryRun is not true. Aborting to prevent live executions." >&2
  exit 1
fi

echo "[INFO] Starting 12h dry-run session. Logs: $MAIN_LOG (human) and $JSON_LOG (raw)."
echo "[INFO] End timestamp (UTC): $(date -u -d @${END_TS} +%Y-%m-%dT%H:%M:%SZ)"

# Trap for clean exit
cleanup() {
  if [[ -f "$PID_FILE" ]]; then rm -f "$PID_FILE"; fi
  echo "[INFO] Dry-run wrapper exiting." | tee -a "$MAIN_LOG"
}
trap cleanup EXIT INT TERM

# Run orchestrator with env expansion and tee logs.
# We assume scripts/dev_env.sh exists next to this script.
(
  cd "$REPO_ROOT" || exit 1
  # Rotate if > 20MB (very simple rotation check)
  rotate_if_needed() {
    local file="$1"
    local max_size=$((20*1024*1024))
    if [[ -f "$file" ]]; then
      local size
      size=$(stat -c%s "$file")
      if (( size > max_size )); then
        mv "$file" "${file%.log}_$(date -u +%H%M%S).log"
      fi
    fi
  }
  export DRYRUN_WRAPPER=1
  while true; do
    NOW=$(date +%s)
    if (( NOW >= END_TS )); then
      echo "[INFO] Reached 12h limit, stopping." | tee -a "$MAIN_LOG"
      break
    fi
    # Single run instance (long-lived process) - break loop after it exits.
  ./scripts/dev_env.sh 2>&1 | while IFS= read -r line; do
      ts=$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)
      echo "[$ts] $line" | tee -a "$MAIN_LOG"
      # Attempt to extract JSON lines produced by pino (if already JSON) and append raw
      if [[ "$line" == \{*\} ]]; then
        echo "$line" >> "$JSON_LOG"
      fi
      rotate_if_needed "$MAIN_LOG"
    done
    # If orchestrator exits early, sleep briefly then decide whether to restart.
  echo "[WARN] Orchestrator process exited early (exit code $?) ; sleeping 15s then evaluating restart." | tee -a "$MAIN_LOG"
    sleep 15
  done
) &
CHILD_PID=$!
echo $CHILD_PID > "$PID_FILE"
echo "[INFO] Orchestrator PID: $CHILD_PID" | tee -a "$MAIN_LOG"

# Wait until duration expires or child exits
while kill -0 $CHILD_PID 2>/dev/null; do
  NOW=$(date +%s)
  if (( NOW >= END_TS )); then
    echo "[INFO] Sending SIGTERM to orchestrator after 12h." | tee -a "$MAIN_LOG"
    kill -TERM $CHILD_PID || true
    break
  fi
  sleep 30
done

wait $CHILD_PID || true

===== END liquidator/scripts/dry_run_12h.sh =====

===== BEGIN liquidator/scripts/check_env.ts =====
import { config as loadEnv } from 'dotenv';
import path from 'path';
import { createPublicClient, http, formatEther } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';

loadEnv();
loadEnv({ path: path.resolve(__dirname, '../../.env') });

function expand(value: string | undefined) {
  if (!value) return value;
  return value.replace(/\$\{([^}]+)\}/g, (_, name) => process.env[name] ?? '');
}

const configs = [
  {
    label: 'Arbitrum',
    rpc: expand(process.env.RPC_ARB),
    pk: process.env.WALLET_PK_ARB,
    expectedChainId: Number(process.env.CHAIN_ID_ARB ?? 42161),
  },
  {
    label: 'Optimism',
    rpc: expand(process.env.RPC_OP),
    pk: process.env.WALLET_PK_OP,
    expectedChainId: Number(process.env.CHAIN_ID_OP ?? 10),
  },
];

async function main() {
  for (const cfg of configs) {
    if (!cfg.rpc) {
      console.warn(`[${cfg.label}] missing RPC URL`);
      continue;
    }
    if (!cfg.pk) {
      console.warn(`[${cfg.label}] missing private key`);
      continue;
    }

    const account = privateKeyToAccount(cfg.pk as `0x${string}`);
    const client = createPublicClient({ transport: http(cfg.rpc) });

    try {
      const chainId = await client.getChainId();
      const balance = await client.getBalance({ address: account.address });
      const match = cfg.expectedChainId ? chainId === cfg.expectedChainId : true;
      const status = match ? 'ok' : `chain-mismatch (expected ${cfg.expectedChainId}, got ${chainId})`;

      console.log(`\n[${cfg.label}] ${status}`);
      console.log(`  address: ${account.address}`);
      console.log(`  balance: ${formatEther(balance)} native`);
    } catch (err) {
      console.error(`\n[${cfg.label}] failed:`, (err as Error).message);
    }
  }
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});

===== END liquidator/scripts/check_env.ts =====

===== BEGIN liquidator/scripts/check_env.js =====
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const dotenv_1 = require("dotenv");
const path_1 = __importDefault(require("path"));
const viem_1 = require("viem");
const accounts_1 = require("viem/accounts");
(0, dotenv_1.config)();
(0, dotenv_1.config)({ path: path_1.default.resolve(__dirname, '../../.env') });
function expand(value) {
    if (!value)
        return value;
    return value.replace(/\$\{([^}]+)\}/g, (_, name) => process.env[name] ?? '');
}
const configs = [
    {
        label: 'Arbitrum',
        rpc: expand(process.env.RPC_ARB),
        pk: process.env.WALLET_PK_ARB,
        expectedChainId: Number(process.env.CHAIN_ID_ARB ?? 42161),
    },
    {
        label: 'Optimism',
        rpc: expand(process.env.RPC_OP),
        pk: process.env.WALLET_PK_OP,
        expectedChainId: Number(process.env.CHAIN_ID_OP ?? 10),
    },
];
async function main() {
    for (const cfg of configs) {
        if (!cfg.rpc) {
            console.warn(`[${cfg.label}] missing RPC URL`);
            continue;
        }
        if (!cfg.pk) {
            console.warn(`[${cfg.label}] missing private key`);
            continue;
        }
        const account = (0, accounts_1.privateKeyToAccount)(cfg.pk);
        const client = (0, viem_1.createPublicClient)({ transport: (0, viem_1.http)(cfg.rpc) });
        try {
            const chainId = await client.getChainId();
            const balance = await client.getBalance({ address: account.address });
            const match = cfg.expectedChainId ? chainId === cfg.expectedChainId : true;
            const status = match ? 'ok' : `chain-mismatch (expected ${cfg.expectedChainId}, got ${chainId})`;
            console.log(`\n[${cfg.label}] ${status}`);
            console.log(`  address: ${account.address}`);
            console.log(`  balance: ${(0, viem_1.formatEther)(balance)} native`);
        }
        catch (err) {
            console.error(`\n[${cfg.label}] failed:`, err.message);
        }
    }
}
main().catch((err) => {
    console.error(err);
    process.exit(1);
});

===== END liquidator/scripts/check_env.js =====

===== BEGIN liquidator/offchain/orchestrator.ts =====
import './infra/env';
import './infra/metrics_server';
import { Address, createPublicClient, http } from 'viem';
import { loadConfig, liquidatorForChain, ChainCfg, AppConfig, TokenInfo } from './infra/config';
import { executorAddressForChain, privateKeyForChain } from './infra/accounts';
import { log } from './infra/logger';
import { counter, gauge } from './infra/metrics';
import { isThrottled, recordAttempt as recordThrottleAttempt } from './infra/throttle';
import { ensureAttemptTable, recordAttemptRow } from './infra/attempts';
import { streamCandidates, type Candidate } from './indexer/aave_indexer';
import { oracleDexGapBps, oraclePriceUsd } from './indexer/price_watcher';
import { simulate, Plan as SimPlan } from './simulator/simulate';
import { sendLiquidation } from './executor/send_tx';
import { getPoolFromProvider, logPoolsAtBoot } from './infra/aave_provider';
import { buildRouteOptions } from './util/routes';
import { serializeCandidate, serializePlan } from './util/serialize';
import { emitAlert } from './infra/alerts';
import { checkSequencerStatus } from './infra/sequencer';
import { createChainWatcher } from './realtime/watchers';
import { shouldPrecommit } from './realtime/oracle_predictor';
import { isKillSwitchActive, killSwitchPath } from './infra/kill_switch';

const DEFAULT_CLOSE_FACTOR_BPS = 5000;
const DEFAULT_BONUS_BPS = 800;
const WAD = 10n ** 18n;
const SEQUENCER_STALE_SECONDS = 120;
const SEQUENCER_RECOVERY_GRACE_SECONDS = 120;
const AUTO_STOP_ON_FAIL_RATE = process.env.FAIL_RATE_AUTO_STOP === '1';
const INVENTORY_MODE = process.env.INVENTORY_MODE !== '0';
const INVENTORY_REFRESH_MS = Number(process.env.INVENTORY_REFRESH_MS ?? 10_000);

const AAVE_POOL_ABI = [
  {
    type: 'function',
    name: 'getUserAccountData',
    stateMutability: 'view',
    inputs: [{ name: 'user', type: 'address' }],
    outputs: [
      { name: 'totalCollateralBase', type: 'uint256' },
      { name: 'totalDebtBase', type: 'uint256' },
      { name: 'availableBorrowsBase', type: 'uint256' },
      { name: 'currentLiquidationThreshold', type: 'uint256' },
      { name: 'ltv', type: 'uint256' },
      { name: 'healthFactor', type: 'uint256' },
    ],
  },
] as const;

// --- Global State ---
const clients = new Map<number, ReturnType<typeof createPublicClient>>();
const pools = new Map<number, Address>();
const inventoryCache = new Map<string, { balance: bigint; fetchedAt: number }>();

const ERC20_ABI = [
  {
    type: 'function',
    name: 'balanceOf',
    stateMutability: 'view',
    inputs: [{ name: 'account', type: 'address' }],
    outputs: [{ name: 'amount', type: 'uint256' }],
  },
  {
    type: 'function',
    name: 'decimals',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ name: '', type: 'uint8' }],
  },
] as const;

// Global counters for overall system monitoring
let plansReadyCount = 0;
let plansSentCount = 0;
let plansErrorCount = 0;
let sessionNotionalUsd = 0;

// Global alert cooldown
let lastFailAlertMs = 0;
const ALERT_COOLDOWN_MS = 15 * 60 * 1000;

// --- Helper Functions ---

async function poolAddress(chain: ChainCfg): Promise<Address> {
  const cached = pools.get(chain.id);
  if (cached) return cached;
  const pool = await getPoolFromProvider(chain.rpc, chain.aaveProvider);
  pools.set(chain.id, pool);
  return pool;
}

function wadToFloat(value: bigint): number {
  if (value === 0n) return 0;
  return Number(value) / Number(WAD);
}

function publicClient(chain: ChainCfg) {
  let client = clients.get(chain.id);
  if (!client) {
    client = createPublicClient({ transport: http(chain.rpc) });
    clients.set(chain.id, client);
  }
  return client;
}

async function inventoryBalance(
  chain: ChainCfg,
  token: TokenInfo,
  contract: Address,
  client: ReturnType<typeof createPublicClient>
): Promise<bigint> {
  const key = `${chain.id}:${token.address.toLowerCase()}`;
  const now = Date.now();
  const cached = inventoryCache.get(key);
  if (cached && now - cached.fetchedAt < INVENTORY_REFRESH_MS) {
    return cached.balance;
  }
  const balance = (await client.readContract({
    address: token.address as Address,
    abi: ERC20_ABI,
    functionName: 'balanceOf',
    args: [contract],
  })) as bigint;
  inventoryCache.set(key, { balance, fetchedAt: now });
  return balance;
}

// --- Chain Agent --- 

async function runChainAgent(chain: ChainCfg, cfg: AppConfig) {
  const agentLog = log.child({ chain: chain.name, chainId: chain.id });
  agentLog.info('starting agent');

  const iterator = streamCandidates(cfg)[Symbol.asyncIterator]();
  let subgraphPromise = iterator.next();
  const realtimeWatcher = await createChainWatcher(chain, cfg);
  let killSwitchNotificationSent = false;

  const processCandidate = async (candidate: Candidate, source: 'subgraph' | 'realtime') => {
    if (isKillSwitchActive()) {
      if (!killSwitchNotificationSent) {
        killSwitchNotificationSent = true;
        const location = killSwitchPath();
        agentLog.error({ killSwitch: location ?? 'env-only' }, 'kill-switch-engaged-stopping');
        await emitAlert(
          'Kill switch engaged',
          { chain: chain.name, chainId: chain.id, killSwitch: location ?? 'env-only' },
          'critical'
        );
      }
      process.exit(0);
      return;
    }
    // This agent only handles candidates for its own chain
    if (candidate.chainId !== chain.id) {
      return;
    }

    counter.candidates.inc({ chain: chain.name });

    const denyAssets = cfg.risk.denyAssets ?? [];
    if (denyAssets.includes(candidate.debt.symbol) || denyAssets.includes(candidate.collateral.symbol)) {
      counter.denylistSkip.inc({ chain: chain.name });
      await recordAttemptRow({ chainId: chain.id, borrower: candidate.borrower, status: 'policy_skip', reason: 'asset-denylist' });
      agentLog.debug({ borrower: candidate.borrower, debt: candidate.debt.symbol, collateral: candidate.collateral.symbol, source }, 'asset-denylist');
      return;
    }

    const policy = cfg.assets[candidate.debt.symbol];
    if (!policy) {
      agentLog.warn({ asset: candidate.debt.symbol, source }, 'missing-policy');
      return;
    }

    const market = cfg.markets.find(
      (m) => m.enabled && m.chainId === candidate.chainId && m.debtAsset === candidate.debt.symbol && m.collateralAsset === candidate.collateral.symbol
    );
    if (!market) {
      agentLog.debug({ market: candidate, source }, 'market-disabled');
      return;
    }

    const client = publicClient(chain);

    const sequencer = await checkSequencerStatus({
      rpcUrl: chain.rpc,
      feed: chain.sequencerFeed,
      staleAfterSeconds: SEQUENCER_STALE_SECONDS,
      recoveryGraceSeconds: SEQUENCER_RECOVERY_GRACE_SECONDS,
    });
    if (!sequencer.ok) {
      counter.sequencerSkip.inc({ chain: chain.name });
      await recordAttemptRow({
        chainId: chain.id,
        borrower: candidate.borrower,
        status: 'policy_skip',
        reason: `sequencer ${sequencer.reason ?? 'unavailable'}`,
      });
      agentLog.debug({ borrower: candidate.borrower, reason: sequencer.reason, updatedAt: sequencer.updatedAt, source }, 'skip-sequencer');
      return;
    }

    const debtToken = chain.tokens[candidate.debt.symbol];
    const collateralToken = chain.tokens[candidate.collateral.symbol];
    if (!debtToken || !collateralToken) {
      agentLog.warn({ candidate, source }, 'token-metadata-missing');
      return;
    }

  let candSnapshot!: ReturnType<typeof serializeCandidate>;
  let plan: SimPlan | null = null;
  try {
      const throttleLimit = cfg.risk.maxAttemptsPerBorrowerHour ?? 0;
      if (!cfg.risk.dryRun) {
        if (await isThrottled(chain.id, candidate.borrower, throttleLimit)) {
          counter.throttled.inc({ chain: chain.name });
          await recordAttemptRow({ chainId: chain.id, borrower: candidate.borrower, status: 'throttled' });
          agentLog.debug({ borrower: candidate.borrower, source }, 'throttled-skip');
          return;
        }
      }

      const debtPriceUsd = await oraclePriceUsd(client, debtToken);
      const collPriceUsd = await oraclePriceUsd(client, collateralToken);
      if (debtPriceUsd == null || collPriceUsd == null) {
        await recordAttemptRow({
          chainId: chain.id,
          borrower: candidate.borrower,
          status: 'policy_skip',
          reason: 'price-missing',
        });
        agentLog.debug({ borrower: candidate.borrower, debt: candidate.debt.symbol, collateral: candidate.collateral.symbol, source }, 'price-missing');
        return;
      }
      const { options: routeOptions, gapFee, gapRouter } = buildRouteOptions(cfg, chain, candidate.debt.symbol, candidate.collateral.symbol);
      const gap = await oracleDexGapBps({
        client,
        chain,
        collateral: collateralToken,
        debt: debtToken,
        fee: gapFee,
        router: gapRouter,
      });
      candSnapshot = serializeCandidate({
        candidate,
        debtToken,
        collateralToken,
        debtPriceUsd,
        collateralPriceUsd: collPriceUsd,
        gapBps: gap,
        routeOptions,
      });
      if (gap > policy.gapCapBps) {
        counter.gapSkip.inc({ chain: chain.name });
        await recordAttemptRow({
          chainId: chain.id,
          borrower: candidate.borrower,
          status: 'gap_skip',
          reason: `gap ${gap}bps`,
          details: { candidate: candSnapshot },
        });
        agentLog.debug({ borrower: candidate.borrower, gap, source }, 'skip-gap');
        return;
      }

      let healthFactor: number | null = null;
      const hfMax = cfg.risk.healthFactorMax ?? 0.98;
      try {
        const pool = await poolAddress(chain);
        const accountData = (await client.readContract({
          abi: AAVE_POOL_ABI,
          address: pool,
          functionName: 'getUserAccountData',
          args: [candidate.borrower],
        })) as readonly [bigint, bigint, bigint, bigint, bigint, bigint];
        healthFactor = wadToFloat(accountData[5]);
        if (!Number.isFinite(healthFactor) || healthFactor <= 0) {
          agentLog.warn({ borrower: candidate.borrower, source }, 'hf-invalid');
          await recordAttemptRow({ chainId: chain.id, borrower: candidate.borrower, status: 'policy_skip', reason: 'hf-invalid' });
          return;
        }
      } catch (hfErr) {
        agentLog.warn({ borrower: candidate.borrower, err: (hfErr as Error).message, source }, 'hf-fetch-failed');
        await recordAttemptRow({ chainId: chain.id, borrower: candidate.borrower, status: 'policy_skip', reason: 'hf-fetch-failed' });
        return;
      }

      const precommitEligible = shouldPrecommit({
        debtFeed: debtToken.chainlinkFeed,
        gapBps: candSnapshot.gapBps ?? gap,
        healthFactor: healthFactor ?? Number.POSITIVE_INFINITY,
        hfMax,
      });
      if ((healthFactor ?? 0) >= hfMax && !precommitEligible) {
        await recordAttemptRow({ chainId: chain.id, borrower: candidate.borrower, status: 'policy_skip', reason: `hf ${healthFactor?.toFixed(4)}` });
        agentLog.debug({ borrower: candidate.borrower, healthFactor, hfMax, source }, 'skip-health-factor');
        return;
      }

      const trigger = (candidate as any).__trigger;
      agentLog.debug({
        borrower: candidate.borrower,
        debtAmount: candidate.debt.amount.toString(),
        collateralAmount: candidate.collateral.amount.toString(),
        routes: routeOptions.map((r) => r.type),
        healthFactor,
        hfMax,
        precommitEligible,
        source,
        trigger,
      }, 'candidate-considered');

      const contract = liquidatorForChain(cfg, chain.id);
      if (!contract || /^0x0+$/.test(contract)) {
        agentLog.warn({ source }, 'missing-liquidator-address');
        return;
      }
      if (!cfg.beneficiary) {
        agentLog.warn({ source }, 'missing-beneficiary-address');
        return;
      }
      const pk = privateKeyForChain(chain);
      if (!pk) {
        agentLog.warn({ source }, 'missing-private-key');
        return;
      }
      const executor = executorAddressForChain(chain);
      if (!executor) {
        agentLog.warn({ source }, 'missing-executor-address');
        return;
      }

      plan = await simulate({
        client,
        chain,
        contract,
        beneficiary: cfg.beneficiary,
        executor,
        borrower: candidate.borrower,
        debt: { ...debtToken, symbol: candidate.debt.symbol, amount: candidate.debt.amount },
        collateral: { ...collateralToken, symbol: candidate.collateral.symbol, amount: candidate.collateral.amount },
        closeFactor: (market.closeFactorBps ?? DEFAULT_CLOSE_FACTOR_BPS) / 10_000,
        bonusBps: market.bonusBps ?? DEFAULT_BONUS_BPS,
        routes: routeOptions,
        pricesUsd: { debt: debtPriceUsd, coll: collPriceUsd },
        policy,
        gasCapUsd: cfg.risk.gasCapUsd,
        maxRepayUsd: cfg.risk.maxRepayUsd,
      });
      // TODO: branch here for RFQ execution once the contract codec supports RFQ calldata payloads.

      if (!plan) {
        agentLog.debug({
          borrower: candidate.borrower,
          debtAmount: candidate.debt.amount.toString(),
          collateralAmount: candidate.collateral.amount.toString(),
          debtPriceUsd,
          collPriceUsd,
          gap,
          gasCapUsd: cfg.risk.gasCapUsd,
          routes: routeOptions.map((r) => r.type),
          healthFactor,
          hfMax,
          source,
          trigger,
        }, 'plan-null');
        const reason = ['plan-null'];
        if (healthFactor !== null) {
          reason.push(`hf ${healthFactor.toFixed(4)}`);
        }
        await recordAttemptRow({
          chainId: chain.id,
          borrower: candidate.borrower,
          status: 'policy_skip',
          reason: reason.join(' '),
          details: { candidate: candSnapshot },
        });
        return;
      }

      counter.plansReady.inc({ chain: chain.name });
      plansReadyCount += 1;
      if (plansReadyCount > 0) {
        gauge.hitRate.set(plansSentCount / plansReadyCount);
      }

      plan.precommit = precommitEligible && (healthFactor ?? 0) >= hfMax;

      if (!cfg.risk.dryRun && INVENTORY_MODE) {
        try {
          const contractAddress = contract as Address;
          const currentBalance = await inventoryBalance(chain, debtToken, contractAddress, client);
          if (currentBalance >= plan.repayAmount) {
            plan.mode = 'funds';
          }
        } catch (err) {
          agentLog.warn({ err: (err as Error).message }, 'inventory-balance-failed');
        }
      }
      if (!plan.mode) plan.mode = 'flash';

      const planSnapshot = serializePlan(plan);
      if (cfg.risk.dryRun) {
        counter.plansDryRun.inc({ chain: chain.name });
        await recordAttemptRow({
          chainId: chain.id,
          borrower: candidate.borrower,
          status: 'dry_run',
          reason: `netBps ${plan.estNetBps.toFixed(2)}`,
          details: { candidate: candSnapshot, plan: planSnapshot },
        });
        agentLog.info({ borrower: candidate.borrower, repay: plan.repayAmount.toString(), netBps: plan.estNetBps, source, trigger }, 'DRY-RUN');
        return;
      }

      if (cfg.risk.pnlPerGasMin > 0 && plan.gasUsd > 0) {
        const estProfitUsd = (plan.estNetBps / 10_000) * plan.repayUsd;
        const pnlPerGas = estProfitUsd / plan.gasUsd;
        gauge.pnlPerGas.set(pnlPerGas);
        if (pnlPerGas < cfg.risk.pnlPerGasMin) {
          await recordAttemptRow({
            chainId: chain.id,
            borrower: candidate.borrower,
            status: 'policy_skip',
            reason: `pnl/gas ${pnlPerGas.toFixed(2)} < ${cfg.risk.pnlPerGasMin}`,
            details: { candidate: candSnapshot, plan: planSnapshot },
          });
          agentLog.debug({ borrower: candidate.borrower, pnlPerGas, min: cfg.risk.pnlPerGasMin, source }, 'skip-pnl-per-gas');
          return;
        }
      }

      const sequencerPreSend = await checkSequencerStatus({
        rpcUrl: chain.rpc,
        feed: chain.sequencerFeed,
        staleAfterSeconds: SEQUENCER_STALE_SECONDS,
        recoveryGraceSeconds: SEQUENCER_RECOVERY_GRACE_SECONDS,
      });
      if (!sequencerPreSend.ok) {
        const reason = `sequencer ${sequencerPreSend.reason ?? 'unavailable'}`;
        agentLog.warn({ borrower: candidate.borrower, reason, source }, 'sequencer-down-skipping-tx');
        await recordAttemptRow({ chainId: chain.id, borrower: candidate.borrower, status: 'policy_skip', reason });
        return;
      }

      await recordThrottleAttempt(chain.id, candidate.borrower, 3600);

      const minProfit = (plan.repayAmount * BigInt(policy.floorBps)) / 10_000n;
      const deadline = BigInt(Math.floor(Date.now() / 1000) + 300);

      if (
        cfg.risk.maxLiveExecutions !== undefined &&
        cfg.risk.maxLiveExecutions > 0 &&
        plansSentCount >= cfg.risk.maxLiveExecutions
      ) {
        agentLog.warn({ txnIdx: plansSentCount, maxLiveExecutions: cfg.risk.maxLiveExecutions, source }, 'live-execution-cap-reached');
        process.exit(0);
      }

      if (
        cfg.risk.maxSessionNotionalUsd !== undefined &&
        cfg.risk.maxSessionNotionalUsd > 0 &&
        sessionNotionalUsd + plan.repayUsd > cfg.risk.maxSessionNotionalUsd
      ) {
        agentLog.warn(
          {
            pendingRepayUsd: plan.repayUsd,
            sessionNotionalUsd,
            maxSessionNotionalUsd: cfg.risk.maxSessionNotionalUsd,
            source,
          },
          'session-notional-cap-hit'
        );
        process.exit(0);
      }

      const txHash = await sendLiquidation(
        chain.id,
        chain.rpc,
        pk,
        contract,
        {
          borrower: candidate.borrower,
          debtAsset: candidate.debt.address,
          collateralAsset: candidate.collateral.address,
          repayAmount: plan.repayAmount,
          dexId: plan.dexId,
          router: plan.router,
          uniFee: plan.uniFee,
          solidlyStable: plan.solidlyStable,
          solidlyFactory: plan.solidlyFactory,
          minProfit,
          amountOutMin: plan.amountOutMin,
          deadline,
          path: plan.path,
          mode: plan.mode,
        },
        chain.privtx,
      );
      if (plan.mode === 'funds') {
        inventoryCache.delete(`${chain.id}:${debtToken.address.toLowerCase()}`);
      }
      counter.plansSent.inc({ chain: chain.name });
      const sentReason = healthFactor !== null ? `hf ${healthFactor.toFixed(4)}` : undefined;
      await recordAttemptRow({
        chainId: chain.id,
        borrower: candidate.borrower,
        status: 'sent',
        reason: sentReason,
        txHash,
        details: { candidate: candSnapshot, plan: planSnapshot, txHash },
      });
      plansSentCount += 1;
      sessionNotionalUsd += plan.repayUsd;
      if (plansReadyCount > 0) {
        gauge.hitRate.set(plansSentCount / plansReadyCount);
      }
      {
        const attempts = plansSentCount + plansErrorCount;
        const failureRatio = attempts > 0 ? plansErrorCount / attempts : 0;
        gauge.failureRate.labels({ chain: chain.name }).set(failureRatio);
      }
      agentLog.info({ borrower: candidate.borrower, netBps: plan.estNetBps, txHash, repayUsd: plan.repayUsd, sessionNotionalUsd, healthFactor, source, trigger, mode: plan.mode, precommit: plan.precommit }, 'liquidation-sent');

      if (
        cfg.risk.maxLiveExecutions !== undefined &&
        cfg.risk.maxLiveExecutions > 0 &&
        plansSentCount >= cfg.risk.maxLiveExecutions
      ) {
        agentLog.warn({ maxLiveExecutions: cfg.risk.maxLiveExecutions, source }, 'live-execution-cap-hit-stopping');
        process.exit(0);
      }
    } catch (err) {
      if (err instanceof Error && err.message === 'HealthFactorNotBelowThreshold') {
        const reason = plan?.precommit ? 'hf-precommit-revert' : 'hf-recovered';
        await recordAttemptRow({ chainId: chain.id, borrower: candidate.borrower, status: 'policy_skip', reason, details: plan ? { plan: serializePlan(plan) } : undefined });
        const logFn = plan?.precommit ? agentLog.info.bind(agentLog) : agentLog.debug.bind(agentLog);
        logFn({ borrower: candidate.borrower, source, precommit: plan?.precommit }, 'skip-hf-recovered');
        return;
      }

      counter.plansError.inc({ chain: chain.name });
      plansErrorCount += 1;
      await recordAttemptRow({
        chainId: chain.id,
        borrower: candidate.borrower,
        status: 'error',
        reason: (err as Error).message,
        details: candSnapshot ? { candidate: candSnapshot } : { candidate },
      });
      const attempts = plansSentCount + plansErrorCount;
      const ratio = attempts > 0 ? plansErrorCount / attempts : 0;
      gauge.failureRate.labels({ chain: chain.name }).set(ratio);
      if (!cfg.risk.dryRun) {
        if (
          attempts >= 5 &&
          cfg.risk.failRateCap > 0 &&
          ratio > cfg.risk.failRateCap &&
          Date.now() - lastFailAlertMs > ALERT_COOLDOWN_MS
        ) {
          lastFailAlertMs = Date.now();
          await emitAlert('Liquidations fail-rate above threshold', {
            chain: chain.name,
            ratio: ratio.toFixed(2),
            attempts,
            errors: plansErrorCount,
          }, 'critical');
          if (AUTO_STOP_ON_FAIL_RATE) {
            agentLog.error({ ratio, attempts, errors: plansErrorCount }, 'fail-rate-cap-exceeded-auto-stop');
            process.exit(1);
          }
        }
      }
      agentLog.error({ err: (err as Error).message, borrower: candidate.borrower, source }, 'candidate-failed');
    }
  };

  try {
    while (true) {
      if (realtimeWatcher) {
        const immediate = realtimeWatcher.tryShift();
        if (immediate) {
          await processCandidate(immediate, 'realtime');
          continue;
        }

        const result = await Promise.race([
          subgraphPromise.then((value) => ({ type: 'subgraph' as const, value })),
          realtimeWatcher
            .next()
            .then((candidate) => ({ type: 'realtime' as const, candidate }))
            .catch(() => ({ type: 'stopped' as const })),
        ]);

        if (result.type === 'stopped') {
          break;
        }

        if (result.type === 'realtime') {
          await processCandidate(result.candidate, 'realtime');
          continue;
        }

        const { done, value } = result.value;
        if (done) break;
        await processCandidate(value, 'subgraph');
        subgraphPromise = iterator.next();
      } else {
        const { done, value } = await subgraphPromise;
        if (done) break;
        await processCandidate(value, 'subgraph');
        subgraphPromise = iterator.next();
      }
    }
  } finally {
    realtimeWatcher?.stop();
  }
}


async function main() {
  const cfg = loadConfig();
  await logPoolsAtBoot(cfg);
  await ensureAttemptTable();
  log.info({ chains: cfg.chains.length }, 'boot');

  const enabledChains = cfg.chains.filter((c) => c.enabled);
  if (enabledChains.length === 0) {
    log.warn('no chains enabled in config, exiting');
    return;
  }

  log.info({ chains: enabledChains.map(c => c.name) }, 'launching agents');
  const agents = enabledChains.map(chain => runChainAgent(chain, cfg));
  await Promise.all(agents);
  log.info('all agents finished');
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});

===== END liquidator/offchain/orchestrator.ts =====

===== BEGIN liquidator/offchain/agent/api.ts =====
import '../infra/env';
import fastify, { type FastifyInstance, type FastifyReply, type FastifyRequest } from 'fastify';
import { createPublicClient, http } from 'viem';

import { loadConfig, chainById } from '../infra/config';
import { log } from '../infra/logger';
import { db } from '../infra/db';
import { stageProposal } from './proposals';
import { serializeRoutes } from '../util/serialize';
import { buildRouteOptions } from '../util/routes';
import { bestRoute } from '../simulator/router';
import { oraclePriceDetails } from '../indexer/price_watcher';

const app: FastifyInstance = fastify({ logger: false });
type AttemptRow = {
  id: number;
  chain_id: number;
  borrower: string;
  status: string;
  reason?: string;
  tx_hash?: string;
  details: any;
  created_at: string;
};
const hasDb = Boolean(process.env.DATABASE_URL);

function getLimit(query: Record<string, any>, fallback = 100): number {
  const raw = query.limit ?? query.n;
  if (!raw) return fallback;
  const parsed = Number(raw);
  if (Number.isNaN(parsed) || parsed <= 0) return fallback;
  return Math.min(parsed, 1000);
}

async function fetchAttempts(limit = 100, seconds?: number) {
  if (!hasDb) {
    throw new Error('DATABASE_URL not configured');
  }
  const params: Array<string | number> = [limit];
  let where = '';
  if (seconds && seconds > 0) {
    params.push(seconds);
    where = `WHERE created_at >= NOW() - ($2 || ' seconds')::interval`;
  }
  const sql = `
    SELECT id, chain_id, borrower, status, reason, tx_hash, details, created_at
    FROM liquidation_attempts
    ${where}
    ORDER BY created_at DESC
    LIMIT $1
  `;
  const res = await db.query(sql, params);
  return (res.rows as AttemptRow[]).map((row) => ({
    id: row.id,
    chainId: row.chain_id,
    borrower: row.borrower,
    status: row.status,
    reason: row.reason,
    txHash: row.tx_hash,
    details: row.details ?? null,
    createdAt: row.created_at,
  }));
}

app.get('/health', async () => ({ status: 'ok', timestamp: new Date().toISOString() }));

app.get('/attempts', async (req: FastifyRequest, reply: FastifyReply) => {
  try {
    const query = req.query as any;
    const limit = getLimit(query ?? {}, 200);
    const seconds = query?.seconds ? Number(query.seconds) : undefined;
    const rows = await fetchAttempts(limit, seconds);
    return { count: rows.length, rows };
  } catch (err) {
    reply.code(503);
    return { error: (err as Error).message };
  }
});

app.get('/metrics', async (req: FastifyRequest, reply: FastifyReply) => {
  try {
    const query = req.query as any;
    const limit = getLimit(query ?? {}, 500);
    const seconds = query?.seconds ? Number(query.seconds) : 3600;
    const rows = await fetchAttempts(limit, seconds);

    const total = rows.length;
    const byStatus: Record<string, number> = {};
    let planned = 0;
    let planTotalBps = 0;
    let errors = 0;

    for (const row of rows) {
      byStatus[row.status] = (byStatus[row.status] ?? 0) + 1;
      if (row.status === 'error') errors += 1;
      const est = row.details?.plan?.estNetBps;
      if (typeof est === 'number') {
        planned += 1;
        planTotalBps += est;
      }
    }
    const avgNetBps = planned ? planTotalBps / planned : 0;
    const errorRate = total ? errors / total : 0;
    return { total, byStatus, planned, avgNetBps, errorRate };
  } catch (err) {
    reply.code(503);
    return { error: (err as Error).message };
  }
});

app.get('/config', async () => {
  const cfg = loadConfig();
  return cfg;
});

function parsePair(pair: string) {
  const [debt, collateral] = pair.split('-');
  if (!debt || !collateral) throw new Error('pair must be formatted like DEBT-COLLATERAL');
  return { debt, collateral };
}

function decimalToBigInt(value: string, decimals: number): bigint {
  const [intPart, fracPart = ''] = value.split('.');
  const cleanInt = intPart || '0';
  const cleanFrac = (fracPart + '0'.repeat(decimals)).slice(0, decimals);
  const intBig = BigInt(cleanInt);
  const fracBig = BigInt(cleanFrac || '0');
  const scale = BigInt(10) ** BigInt(decimals);
  return intBig * scale + fracBig;
}

app.get('/quotes', async (req: FastifyRequest, reply: FastifyReply) => {
  const query = req.query as any;
  const cfg = loadConfig();
  const chainId = Number(query.chain ?? query.chainId ?? cfg.chains[0]?.id);
  const pairInput = query.pair ?? 'USDC-WETH';
  const amountInput = query.amount ?? '1';
  const slippageBps = Number(query.slippage ?? 0);

  const chain = chainById(cfg, chainId);
  if (!chain) {
    reply.code(400);
    return { error: `Unknown chain ${chainId}` };
  }

  const { debt, collateral } = parsePair(pairInput);
  const debtToken = chain.tokens[debt];
  const collateralToken = chain.tokens[collateral];
  if (!debtToken || !collateralToken) {
    reply.code(400);
    return { error: `Unsupported pair ${pairInput} on chain ${chainId}` };
  }

  const amountIn = decimalToBigInt(String(amountInput), debtToken.decimals);
  const client = createPublicClient({ transport: http(chain.rpc) });
  const { options } = buildRouteOptions(cfg, chain, debt, collateral);

  const quotes = await Promise.all(
    options.map(async (option) => {
      const routeSnapshot = serializeRoutes([option])[0];
      try {
        const result = await bestRoute({
          client,
          chain,
          collateral: collateralToken,
          debt: debtToken,
          seizeAmount: amountIn,
          slippageBps,
          options: [option],
        });
        if (!result) {
          return { route: routeSnapshot, error: 'no-quote' };
        }
        return {
          route: routeSnapshot,
          amountOutMin: result.amountOutMin.toString(),
          quotedOut: result.quotedOut.toString(),
        };
      } catch (err) {
        return { route: routeSnapshot, error: (err as Error).message };
      }
    })
  );

  const best = await bestRoute({
    client,
    chain,
    collateral: collateralToken,
    debt: debtToken,
    seizeAmount: amountIn,
    slippageBps,
    options,
  });

  return {
    chainId,
    pair: pairInput,
    amountIn: amountIn.toString(),
    quotes,
    best: best
      ? {
          dexId: best.dexId,
          router: best.router,
          uniFee: best.uniFee,
          solidlyStable: best.solidlyStable,
          solidlyFactory: best.solidlyFactory,
          amountOutMin: best.amountOutMin.toString(),
          quotedOut: best.quotedOut.toString(),
        }
      : null,
  };
});

app.get('/oracles', async (req: FastifyRequest, reply: FastifyReply) => {
  const query = req.query as any;
  const cfg = loadConfig();
  const chainId = Number(query.chain ?? query.chainId ?? cfg.chains[0]?.id);
  const chain = chainById(cfg, chainId);
  if (!chain) {
    reply.code(400);
    return { error: `Unknown chain ${chainId}` };
  }
  const client = createPublicClient({ transport: http(chain.rpc) });
  const results = [] as Array<Record<string, unknown>>;
  for (const [symbol, token] of Object.entries(chain.tokens)) {
    const detail = await oraclePriceDetails(client, token);
    results.push({ symbol, address: token.address, ...detail });
  }
  return { chainId, results };
});

app.post('/propose', async (req: FastifyRequest, reply: FastifyReply) => {
  try {
    const body = req.body as any;
    if (!body?.patch) {
      reply.code(400);
      return { error: 'patch field is required' };
    }
    const metadata = await stageProposal({
      patch: body.patch,
      hypothesis: body.hypothesis,
      successMetric: body.successMetric,
      killSwitch: body.killSwitch,
      author: body.author,
      source: body.source,
    });
    return { staged: metadata.stagedConfig, metadata };
  } catch (err) {
    reply.code(400);
    return { error: (err as Error).message };
  }
});

const port = Number(process.env.AGENT_API_PORT ?? 8787);
const host = process.env.AGENT_API_HOST ?? '0.0.0.0';

app
  .listen({ port, host })
  .then(() => {
    log.info({ port, host }, 'agent-api-started');
  })
  .catch((err: unknown) => {
    log.error({ err }, 'agent-api-failed');
    process.exit(1);
  });

===== END liquidator/offchain/agent/api.ts =====

===== BEGIN liquidator/offchain/agent/apply_staged.ts =====
import '../infra/env';
import fs from 'fs/promises';
import path from 'path';
import YAML from 'yaml';

import { log } from '../infra/logger';
import { runBacktest } from './backtest';
import { loadStagedConfig, readLatestMetadata, resolveStagePath } from './proposals';
import type { AppConfig } from '../infra/config';

const BASE_CONFIG_PATH = 'config.yaml';
const PREV_CONFIG_PATH = process.env.AGENT_PREV_FILE ?? 'config.prev.yaml';
const CANARY_CONFIG_PATH = process.env.AGENT_CANARY_FILE ?? 'config.canary.yaml';
const REPORT_PATH = process.env.AGENT_REPORT_FILE ?? path.resolve('agent', 'latest-report.json');

function parseArgs() {
  const args = process.argv.slice(2);
  const flags = new Set<string>();
  const values: Record<string, string> = {};
  for (let i = 0; i < args.length; i += 1) {
    const arg = args[i];
    if (!arg.startsWith('--')) continue;
    const key = arg.slice(2);
    const next = args[i + 1];
    if (next && !next.startsWith('--')) {
      values[key] = next;
      i += 1;
    } else {
      flags.add(key);
    }
  }
  return { flags, values };
}

function gateResult(result: Awaited<ReturnType<typeof runBacktest>>) {
  const { baselinePlans, newPlans, baselineAvgNetBps, newAvgNetBps } = result;
  if (baselinePlans === 0) {
    return { pass: true, reason: 'baseline has no plan data (skipping gate)' };
  }
  if (newPlans < baselinePlans * 0.8) {
    return { pass: false, reason: `new plan count ${newPlans} < 80% of baseline ${baselinePlans}` };
  }
  if (baselineAvgNetBps > 0 && newAvgNetBps < baselineAvgNetBps * 0.95) {
    return {
      pass: false,
      reason: `avg net bps ${newAvgNetBps.toFixed(2)} below 95% of baseline ${baselineAvgNetBps.toFixed(2)}`,
    };
  }
  return { pass: true, reason: 'gates passed' };
}

async function writeReport(report: unknown) {
  const json = JSON.stringify(report, null, 2);
  await fs.mkdir(path.dirname(REPORT_PATH), { recursive: true });
  await fs.writeFile(REPORT_PATH, json, 'utf8');
}

async function main() {
  const { flags, values } = parseArgs();
  const limit = values.limit ? Number(values.limit) : undefined;
  const seconds = values.seconds ? Number(values.seconds) : undefined;
  const apply = flags.has('apply');
  const canary = flags.has('canary');

  const stagePath = resolveStagePath();
  const stagedConfig = (await loadStagedConfig()) as AppConfig;

  const result = await runBacktest({ config: stagedConfig, limit, seconds });
  const gate = gateResult(result);
  const metadata = await readLatestMetadata();

  const report = {
    gate,
    result,
    stagePath,
    metadata,
  };

  await writeReport(report);

  log.info(report, 'agent-backtest-report');

  if (!gate.pass) {
    log.error({ reason: gate.reason }, 'proposal-gate-failed');
    process.exitCode = 1;
    return;
  }

  if (canary) {
    await fs.writeFile(CANARY_CONFIG_PATH, YAML.stringify(stagedConfig), 'utf8');
    log.info({ config: CANARY_CONFIG_PATH }, 'canary-config-written');
  }

  if (!apply) {
    log.info('use --apply to promote staged config to production');
    return;
  }

  await fs.copyFile(BASE_CONFIG_PATH, PREV_CONFIG_PATH).catch(() => {});
  await fs.copyFile(stagePath, BASE_CONFIG_PATH);
  log.info({ promoted: BASE_CONFIG_PATH, backup: PREV_CONFIG_PATH }, 'config-promoted');
}

main().catch((err) => {
  console.error('agent apply failed:', err);
  process.exit(1);
});

===== END liquidator/offchain/agent/apply_staged.ts =====

===== BEGIN liquidator/offchain/agent/backtest.ts =====
import '../infra/env';
import { createPublicClient, http } from 'viem';

import { loadConfig, chainById, AppConfig, Market, liquidatorForChain } from '../infra/config';
import { executorAddressForChain } from '../infra/accounts';
import { log } from '../infra/logger';
import { db } from '../infra/db';
import { buildRouteOptions } from '../util/routes';
import { simulate } from '../simulator/simulate';
import { oraclePriceUsd } from '../indexer/price_watcher';

const DEFAULT_CLOSE_FACTOR_BPS = 5000;
const DEFAULT_BONUS_BPS = 800;

const hasDb = Boolean(process.env.DATABASE_URL);

export type BacktestOptions = {
  config?: AppConfig;
  configPath?: string;
  limit?: number;
  seconds?: number;
};

export type BacktestResult = {
  samples: number;
  newPlans: number;
  newAvgNetBps: number;
  baselinePlans: number;
  baselineAvgNetBps: number;
  baselineErrorRate: number;
  skipped: number;
  failures: Array<{ borrower: string; chainId: number; reason: string }>;
};

type AttemptRow = {
  chain_id: number;
  borrower: string;
  status: string;
  details: any;
  created_at: Date;
};

function bigIntFromString(value: string | number | bigint): bigint {
  if (typeof value === 'bigint') return value;
  if (typeof value === 'number') return BigInt(Math.floor(value));
  if (typeof value === 'string') return value.startsWith('0x') ? BigInt(value) : BigInt(value);
  throw new Error('invalid bigint input');
}

function resolvePolicy(config: AppConfig, market: Market | undefined, debtSymbol: string) {
  const policy = config.assets[debtSymbol];
  if (!policy) return null;
  const closeFactor = (market?.closeFactorBps ?? DEFAULT_CLOSE_FACTOR_BPS) / 10_000;
  const bonusBps = market?.bonusBps ?? DEFAULT_BONUS_BPS;
  return { policy, closeFactor, bonusBps };
}

async function fetchAttemptRows(limit: number, seconds?: number): Promise<AttemptRow[]> {
  if (!hasDb) {
    throw new Error('DATABASE_URL not configured; cannot run backtest');
  }
  const params: Array<string | number> = [limit];
  let where = '';
  if (seconds && seconds > 0) {
    params.push(seconds);
    where = `WHERE created_at >= NOW() - ($2 || ' seconds')::interval`;
  }
  const sql = `
    SELECT chain_id, borrower, status, details, created_at
    FROM liquidation_attempts
    ${where}
    ORDER BY created_at DESC
    LIMIT $1
  `;
  const res = await db.query(sql, params);
  return res.rows as AttemptRow[];
}

function getSampleDetails(row: AttemptRow) {
  const details = row.details ?? {};
  const candidate = details.candidate;
  if (!candidate) return null;
  return { candidate, baselinePlan: details.plan, status: row.status };
}

export async function runBacktest(options: BacktestOptions = {}): Promise<BacktestResult> {
  const config = options.config ?? loadConfig(options.configPath);
  const limit = options.limit ?? 200;
  const seconds = options.seconds;
  const rows = await fetchAttemptRows(limit, seconds);

  const clientCache = new Map<number, ReturnType<typeof createPublicClient>>();
  const getClient = (rpc: string, chainId: number) => {
    if (!clientCache.has(chainId)) {
      clientCache.set(chainId, createPublicClient({ transport: http(rpc) }));
    }
    return clientCache.get(chainId)!;
  };

  let samples = 0;
  let skipped = 0;
  let newPlans = 0;
  let newNetTotal = 0;
  let baselinePlans = 0;
  let baselineNetTotal = 0;
  let errors = 0;
  const failures: Array<{ borrower: string; chainId: number; reason: string }> = [];

  for (const row of rows) {
    const snapshot = getSampleDetails(row);
    if (!snapshot) {
      skipped += 1;
      continue;
    }
    const { candidate, baselinePlan, status } = snapshot;
    const chain = chainById(config, candidate.chainId);
    if (!chain) {
      skipped += 1;
      failures.push({ borrower: candidate.borrower, chainId: candidate.chainId, reason: 'unknown-chain' });
      continue;
    }
    const debtToken = chain.tokens[candidate.debt.symbol];
    const collateralToken = chain.tokens[candidate.collateral.symbol];
    if (!debtToken || !collateralToken) {
      skipped += 1;
      failures.push({ borrower: candidate.borrower, chainId: candidate.chainId, reason: 'missing-token' });
      continue;
    }
    const market = config.markets.find(
      (m) =>
        m.chainId === candidate.chainId &&
        m.debtAsset === candidate.debt.symbol &&
        m.collateralAsset === candidate.collateral.symbol
    );
    if (!market || !market.enabled) {
      skipped += 1;
      failures.push({ borrower: candidate.borrower, chainId: candidate.chainId, reason: 'market-disabled' });
      continue;
    }
    const policyInfo = resolvePolicy(config, market, candidate.debt.symbol);
    if (!policyInfo) {
      skipped += 1;
      failures.push({ borrower: candidate.borrower, chainId: candidate.chainId, reason: 'missing-policy' });
      continue;
    }

    const client = getClient(chain.rpc, chain.id);
    const debtPrice =
      candidate.debtPriceUsd ?? (await oraclePriceUsd(client, debtToken)) ?? 1;
    const collPrice =
      candidate.collateralPriceUsd ?? (await oraclePriceUsd(client, collateralToken)) ?? debtPrice;

    const contract = liquidatorForChain(config, candidate.chainId);
    if (!contract) {
      skipped += 1;
      failures.push({ borrower: candidate.borrower, chainId: candidate.chainId, reason: 'missing-contract' });
      continue;
    }
    if (!config.beneficiary) {
      skipped += 1;
      failures.push({ borrower: candidate.borrower, chainId: candidate.chainId, reason: 'missing-beneficiary' });
      continue;
    }

    const executor = executorAddressForChain(chain);
    if (!executor) {
      skipped += 1;
      failures.push({ borrower: candidate.borrower, chainId: candidate.chainId, reason: 'missing-executor' });
      continue;
    }

    const routes = buildRouteOptions(config, chain, candidate.debt.symbol, candidate.collateral.symbol).options;
    const plan = await simulate({
      client,
      chain,
      contract,
      beneficiary: config.beneficiary,
      executor,
      borrower: candidate.borrower,
      debt: {
        ...debtToken,
        symbol: candidate.debt.symbol,
        amount: bigIntFromString(candidate.debt.amount),
      },
      collateral: {
        ...collateralToken,
        symbol: candidate.collateral.symbol,
        amount: bigIntFromString(candidate.collateral.amount),
      },
      closeFactor: policyInfo.closeFactor,
      bonusBps: policyInfo.bonusBps,
      routes,
      pricesUsd: { debt: debtPrice, coll: collPrice },
      policy: policyInfo.policy,
      gasCapUsd: config.risk.gasCapUsd,
    });

    samples += 1;

    if (baselinePlan && typeof baselinePlan.estNetBps === 'number') {
      baselinePlans += 1;
      baselineNetTotal += baselinePlan.estNetBps;
    }
    if (status === 'error') {
      errors += 1;
    }

    if (plan) {
      newPlans += 1;
      newNetTotal += plan.estNetBps;
    } else {
      failures.push({ borrower: candidate.borrower, chainId: candidate.chainId, reason: 'plan-null-new-config' });
    }
  }

  const newAvgNetBps = newPlans ? newNetTotal / newPlans : 0;
  const baselineAvgNetBps = baselinePlans ? baselineNetTotal / baselinePlans : 0;
  const baselineErrorRate = samples ? errors / samples : 0;

  const summary: BacktestResult = {
    samples,
    newPlans,
    newAvgNetBps,
    baselinePlans,
    baselineAvgNetBps,
    baselineErrorRate,
    skipped,
    failures: failures.slice(0, 25),
  };

  return summary;
}

export async function runBacktestCLI() {
  try {
    const limitArg = process.argv.indexOf('--limit');
    const limit = limitArg !== -1 ? Number(process.argv[limitArg + 1]) : undefined;
    const secondsArg = process.argv.indexOf('--seconds');
    const seconds = secondsArg !== -1 ? Number(process.argv[secondsArg + 1]) : undefined;
    const staged = process.argv.indexOf('--staged') !== -1;

    const config = staged ? loadConfig(process.env.AGENT_STAGE_FILE ?? 'config.staged.yaml') : loadConfig();
    const result = await runBacktest({ config, limit, seconds });
    log.info({ result }, 'backtest-complete');
    console.log(JSON.stringify(result, null, 2));
  } catch (err) {
    console.error('Backtest failed:', (err as Error).message);
    process.exit(1);
  }
}

if (require.main === module) {
  runBacktestCLI();
}

===== END liquidator/offchain/agent/backtest.ts =====

===== BEGIN liquidator/offchain/agent/proposals.ts =====
import fs from 'fs/promises';
import path from 'path';
import YAML from 'yaml';

import { loadConfig } from '../infra/config';
import { deepMerge } from '../util/deepMerge';
import { log } from '../infra/logger';

const DEFAULT_STAGE_FILE = process.env.AGENT_STAGE_FILE ?? 'config.staged.yaml';
const DEFAULT_PROPOSAL_DIR = process.env.AGENT_PROPOSAL_DIR ?? path.resolve(process.cwd(), 'agent', 'proposals');

export type ProposalInput = {
  patch: string;
  hypothesis?: string;
  successMetric?: string;
  killSwitch?: string;
  author?: string;
  source?: string;
};

export type ProposalMetadata = ProposalInput & {
  id: string;
  createdAt: string;
  patchFile: string;
  stagedConfig: string;
};

async function ensureProposalDir(dir: string) {
  await fs.mkdir(dir, { recursive: true });
}

function timestampId(): string {
  return new Date().toISOString().replace(/[:.]/g, '-');
}

function parsePatch(yamlText: string): Record<string, unknown> {
  const parsed = YAML.parse(yamlText);
  if (parsed === null || typeof parsed !== 'object' || Array.isArray(parsed)) {
    throw new Error('Patch must be a YAML mapping object');
  }
  return parsed as Record<string, unknown>;
}

export async function stageProposal(input: ProposalInput, opts?: { baseConfigPath?: string; proposalDir?: string; stageFile?: string }) {
  const proposalDir = opts?.proposalDir ?? DEFAULT_PROPOSAL_DIR;
  const stageFile = opts?.stageFile ?? DEFAULT_STAGE_FILE;
  await ensureProposalDir(proposalDir);

  const patchObject = parsePatch(input.patch);
  const baseConfigPath = opts?.baseConfigPath ?? 'config.yaml';
  const baseConfig = loadConfig(baseConfigPath);
  const stagedConfig = deepMerge(baseConfig as any, patchObject);

  const stagedYaml = YAML.stringify(stagedConfig);
  await fs.writeFile(stageFile, stagedYaml, 'utf8');

  const id = timestampId();
  const patchFilename = path.join(proposalDir, `${id}.patch.yaml`);
  const metadataFilename = path.join(proposalDir, `${id}.json`);

  await fs.writeFile(patchFilename, input.patch.trim() + '\n', 'utf8');

  const metadata: ProposalMetadata = {
    id,
    createdAt: new Date().toISOString(),
    patchFile: patchFilename,
    stagedConfig: path.resolve(stageFile),
    ...input,
  };

  await fs.writeFile(metadataFilename, JSON.stringify(metadata, null, 2), 'utf8');
  log.info({ id, stageFile }, 'proposal-staged');
  return metadata;
}

export async function readLatestMetadata(proposalDir = DEFAULT_PROPOSAL_DIR): Promise<ProposalMetadata | null> {
  try {
    const entries = await fs.readdir(proposalDir);
    const jsonFiles = entries.filter((name) => name.endsWith('.json')).sort();
    if (!jsonFiles.length) return null;
    const latest = jsonFiles[jsonFiles.length - 1];
    const raw = await fs.readFile(path.join(proposalDir, latest), 'utf8');
    return JSON.parse(raw) as ProposalMetadata;
  } catch (err) {
    if ((err as NodeJS.ErrnoException).code === 'ENOENT') return null;
    throw err;
  }
}

export async function loadStagedConfig(stageFile = DEFAULT_STAGE_FILE) {
  try {
    const raw = await fs.readFile(stageFile, 'utf8');
    return YAML.parse(raw);
  } catch (err) {
    if ((err as NodeJS.ErrnoException).code === 'ENOENT') {
      throw new Error(`Staged config not found at ${stageFile}. Stage a proposal first.`);
    }
    throw err;
  }
}

export function resolveStagePath(stageFile = DEFAULT_STAGE_FILE): string {
  return path.resolve(stageFile);
}

export function resolveProposalDir(dir = DEFAULT_PROPOSAL_DIR): string {
  return path.resolve(dir);
}

===== END liquidator/offchain/agent/proposals.ts =====

===== BEGIN liquidator/offchain/agent/runner.ts =====
import '../infra/env';
import fs from 'fs/promises';
import path from 'path';
import YAML from 'yaml';
import { OpenAI } from 'openai';

import { loadConfig } from '../infra/config';
import { log } from '../infra/logger';
import { db } from '../infra/db';
import { stageProposal } from './proposals';

const hasDb = Boolean(process.env.DATABASE_URL);
const OPENAI_MODEL = process.env.OPENAI_MODEL || 'gpt-4o-mini';

if (!process.env.OPENAI_API_KEY) {
  throw new Error('OPENAI_API_KEY must be set to run the agent');
}

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

async function fetchRecentAttempts(limit = 200, seconds = 3600) {
  if (!hasDb) {
    throw new Error('DATABASE_URL not configured; cannot inspect attempts');
  }
  const sql = `
    SELECT chain_id, borrower, status, reason, details, created_at
    FROM liquidation_attempts
    WHERE created_at >= NOW() - ($2 || ' seconds')::interval
    ORDER BY created_at DESC
    LIMIT $1
  `;
  const res = await db.query(sql, [limit, seconds]);
  return res.rows;
}

function aggregateAttempts(rows: any[]) {
  const byStatus: Record<string, number> = {};
  const byReason: Record<string, number> = {};
  const perChain: Record<number, { total: number; netBps: number; count: number }> = {};
  const misses: Array<Record<string, unknown>> = [];

  for (const row of rows) {
    byStatus[row.status] = (byStatus[row.status] ?? 0) + 1;
    if (row.reason) {
      byReason[row.reason] = (byReason[row.reason] ?? 0) + 1;
    }
    const chainSummary = (perChain[row.chain_id] = perChain[row.chain_id] || { total: 0, netBps: 0, count: 0 });
    chainSummary.total += 1;
    const est = row.details?.plan?.estNetBps;
    if (typeof est === 'number') {
      chainSummary.netBps += est;
      chainSummary.count += 1;
    }
    if (row.status !== 'sent' && row.details?.candidate) {
      misses.push({
        chainId: row.chain_id,
        borrower: row.borrower,
        status: row.status,
        reason: row.reason,
        candidate: row.details.candidate,
      });
    }
  }

  const chains = Object.entries(perChain).map(([chainId, stats]) => ({
    chainId: Number(chainId),
    samples: stats.total,
    avgNetBps: stats.count ? stats.netBps / stats.count : 0,
  }));

  return {
    total: rows.length,
    byStatus,
    byReason,
    chains,
    misses: misses.slice(0, 20),
  };
}

function trimConfig(config: ReturnType<typeof loadConfig>) {
  return {
    assets: config.assets,
    routing: config.routing,
    risk: config.risk,
  };
}

function buildPrompt(config: ReturnType<typeof loadConfig>, summary: ReturnType<typeof aggregateAttempts>) {
  const configSnippet = YAML.stringify(trimConfig(config));
  const summarySnippet = JSON.stringify(summary, null, 2);
  return `You are an L2 liquidation strategist. Review the recent results and propose at most one YAML patch that improves profits without increasing risk. Respond strictly in JSON with shape {"analysis": string, "patch": string, "hypothesis": string, "successMetric": string, "killSwitch": string}. The patch must be a YAML mapping touching only routing, assets, or risk fields.

Current config (excerpt):
${configSnippet}

Recent metrics:
${summarySnippet}`;
}

async function run() {
  const config = loadConfig();
  const attempts = await fetchRecentAttempts();
  const summary = aggregateAttempts(attempts);
  const prompt = buildPrompt(config, summary);

  const completion = await openai.responses.create({
    model: OPENAI_MODEL,
    reasoning: { effort: 'medium' },
    input: [
      {
        role: 'system',
        content:
          'You are an expert quant/DevOps assistant for an L2 liquidation bot. Always emit valid JSON with the fields analysis, patch, hypothesis, successMetric, killSwitch. The patch must be YAML and syntactically correct. Avoid changing safety guards like minProfit or pnlPerGasMin.',
      },
      { role: 'user', content: prompt },
    ],
  });

  const outputText = completion.output_text;
  if (!outputText) {
    throw new Error('LLM response missing output_text');
  }

  let parsed: any;
  try {
    parsed = JSON.parse(outputText.trim());
  } catch (err) {
    throw new Error(`Failed to parse LLM JSON: ${(err as Error).message}`);
  }

  if (!parsed.patch || typeof parsed.patch !== 'string' || !parsed.patch.trim()) {
    throw new Error('LLM did not provide a patch field');
  }

  const metadata = await stageProposal({
    patch: parsed.patch,
    hypothesis: parsed.hypothesis,
    successMetric: parsed.successMetric,
    killSwitch: parsed.killSwitch,
    source: 'llm-agent',
  });

  const reportDir = path.dirname(metadata.patchFile);
  await fs.writeFile(
    path.join(reportDir, `${metadata.id}.analysis.json`),
    JSON.stringify({ summary, analysis: parsed.analysis }, null, 2),
    'utf8'
  );

  log.info({ metadata, analysis: parsed.analysis }, 'agent-proposal-staged');
  console.log('Proposal staged at', metadata.stagedConfig);
  console.log('Analysis:', parsed.analysis);
}

run().catch((err) => {
  console.error('agent runner failed:', err);
  process.exit(1);
});

===== END liquidator/offchain/agent/runner.ts =====

===== BEGIN liquidator/offchain/analysis/diagnose.ts =====
import OpenAI from 'openai';
import { AppConfig } from '../infra/config';

let openai: OpenAI | undefined;

function client(cfg: AppConfig): OpenAI | undefined {
  if (openai) return openai;
  const apiKey = cfg.analysis?.openaiKey;
  if (!apiKey) return undefined;
  openai = new OpenAI({ apiKey });
  return openai;
}

export async function diagnoseFailure(cfg: AppConfig, context: any): Promise<string | null> {
  const c = client(cfg);
  if (!c) return null;

  const prompt = `
    As a world-class quant engineer from the YC-founder collective, analyze the following failed liquidation attempt.
    Your prime directive is to identify the most likely root cause to help us capture >=90% of opportunities safely.

    Context:
    ${JSON.stringify(context, null, 2)}

    Instructions:
    1. State the most likely root cause in a single, concise sentence.
    2. Provide a brief, 2-3 sentence explanation of why this is the likely cause, referencing the context provided.
    3. Suggest a concrete next step for investigation (e.g., "Check liquidity on Camelot for this pair," or "Verify oracle price against DEX price at time of failure.").
    4. Be concise, professional, and direct.
  `;

  try {
    const completion = await c.chat.completions.create({
      model: 'gpt-4-turbo',
      messages: [{ role: 'system', content: prompt }],
      temperature: 0.1,
      max_tokens: 250,
    });
    return completion.choices[0].message.content;
  } catch (err) {
    return `OpenAI diagnosis failed: ${(err as Error).message}`;
  }
}

===== END liquidator/offchain/analysis/diagnose.ts =====

===== BEGIN liquidator/offchain/executor/allow_router.ts =====
import { Address, createPublicClient, http } from 'viem';
import { wallet } from './mev_protect';
import { AppConfig, ChainCfg } from '../infra/config';
import { buildRouteOptions } from '../util/routes';
import { log } from '../infra/logger';

const ROUTER_ADMIN_ABI = [
  {
    type: 'function',
    name: 'allowedRouters',
    stateMutability: 'view',
    inputs: [{ name: '', type: 'address' }],
    outputs: [{ name: '', type: 'bool' }],
  },
  {
    type: 'function',
    name: 'setRouterAllowed',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'router', type: 'address' },
      { name: 'allowed', type: 'bool' },
    ],
    outputs: [],
  },
] as const;

type Params = {
  cfg: AppConfig;
  chain: ChainCfg;
  contract: Address;
  pk: `0x${string}`;
};

function collectRouters(cfg: AppConfig, chain: ChainCfg): Address[] {
  const routers = new Set<Address>();

  for (const market of cfg.markets) {
    if (!market.enabled || market.chainId !== chain.id) continue;
    const { options } = buildRouteOptions(cfg, chain, market.debtAsset, market.collateralAsset);
    for (const option of options) {
      routers.add(option.router);
    }
  }

  const dex = cfg.dexRouters?.[chain.id];
  const pushMaybe = (value: unknown) => {
    if (typeof value !== 'string') return;
    if (!value.startsWith('0x') || value.length !== 42) return;
    routers.add(value as Address);
  };

  if (dex) {
    for (const value of Object.values(dex)) {
      if (typeof value === 'object' && value !== null) {
        for (const nested of Object.values(value)) {
          pushMaybe(nested);
        }
      } else {
        pushMaybe(value);
      }
    }
  }

  pushMaybe(chain.uniV3Router);

  return Array.from(routers);
}

export async function ensureRoutersAllowed({ cfg, chain, contract, pk }: Params): Promise<void> {
  if (!chain.enabled) return;
  const routers = collectRouters(cfg, chain);
  if (!routers.length) return;

  const client = createPublicClient({ transport: http(chain.rpc) });
  const ownerWallet = wallet(chain.rpc, pk);

  for (const router of routers) {
    try {
      const allowed = await client.readContract({
        abi: ROUTER_ADMIN_ABI,
        address: contract,
        functionName: 'allowedRouters',
        args: [router],
      });
      if (allowed) continue;
    } catch (err) {
      log.warn({ chain: chain.id, router, err: (err as Error).message }, 'router-allow-check-failed');
      continue;
    }

    try {
      log.info({ chain: chain.id, router }, 'router-allow-start');
      const hash = await ownerWallet.writeContract({
        abi: ROUTER_ADMIN_ABI,
        address: contract,
        functionName: 'setRouterAllowed',
        args: [router, true],
        chain: undefined,
      });
      log.info({ chain: chain.id, router, hash }, 'router-allow-ok');
    } catch (err) {
      log.error({ chain: chain.id, router, err: (err as Error).message }, 'router-allow-failed');
    }
  }
}

===== END liquidator/offchain/executor/allow_router.ts =====

===== BEGIN liquidator/offchain/executor/build_tx.ts =====
import { Address } from 'viem';

export type BuildArgs = {
  borrower: Address;
  debtAsset: Address;
  collateralAsset: Address;
  repayAmount: bigint;
  dexId: number;
  router: Address;
  uniFee: number;
  solidlyStable?: boolean;
  solidlyFactory?: Address;
  minProfit: bigint;
  amountOutMin: bigint;
  deadline: bigint;
  path?: `0x${string}`;
  mode?: 'flash' | 'funds';
};

export function encodePlan(args: BuildArgs) {
  const path = args.path ?? ('0x' as `0x${string}`);
  const targetFn = args.mode === 'funds' ? 'liquidateWithFunds' : 'liquidateWithFlash';
  return {
    functionName: targetFn,
    args: [
      {
        borrower: args.borrower,
        debtAsset: args.debtAsset,
        collateralAsset: args.collateralAsset,
        repayAmount: args.repayAmount,
        dexId: args.dexId,
        router: args.router,
        uniFee: args.uniFee,
        solidlyStable: args.solidlyStable ?? false,
        solidlyFactory: args.solidlyFactory ?? ('0x0000000000000000000000000000000000000000' as Address),
        minProfit: args.minProfit,
        amountOutMin: args.amountOutMin,
        deadline: args.deadline,
        path,
      },
    ],
  } as const;
}

===== END liquidator/offchain/executor/build_tx.ts =====

===== BEGIN liquidator/offchain/executor/mev_protect.ts =====
import { HttpTransport, createWalletClient, http } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';

export function wallet(chainRpc: string, pk: `0x${string}`, privateRpc?: string) {
  const account = privateKeyToAccount(pk);
  const transport = privateRpc ? http(privateRpc) : http(chainRpc);

  return createWalletClient({ chain: undefined as any, account, transport: transport as HttpTransport });
}

===== END liquidator/offchain/executor/mev_protect.ts =====

===== BEGIN liquidator/offchain/executor/send_tx.ts =====
import { Address, BaseError, ContractFunctionRevertedError, createPublicClient, http } from 'viem';
import { arbitrum, optimism, base, polygon } from 'viem/chains';
import { wallet } from './mev_protect';
import { encodePlan } from './build_tx';
import LiquidatorAbi from './Liquidator.abi.json';
import { instrument } from '../infra/instrument';

const HEALTH_FACTOR_ERROR = 'HealthFactorNotBelowThreshold';
const HEALTH_FACTOR_SELECTOR = '0x930bb771';

const CHAINS: Record<number, any> = { 42161: arbitrum, 10: optimism, 8453: base, 137: polygon };

function isHealthFactorError(err: unknown): boolean {
  if (err instanceof BaseError) {
    const revert = err.walk((error) => error instanceof ContractFunctionRevertedError);
    if (revert instanceof ContractFunctionRevertedError) {
      const errorName = revert.data?.errorName ?? (revert as any).errorName;
      if (errorName === HEALTH_FACTOR_ERROR) {
        return true;
      }

      const signature =
        (revert.data as any)?.errorSignature ??
        (revert.data as any)?.signature ??
        (revert as any).signature;
      if (signature === HEALTH_FACTOR_SELECTOR) {
        return true;
      }

      const raw = (revert.data as any)?.data ?? (revert as any).data;
      if (typeof raw === 'string' && raw.startsWith(HEALTH_FACTOR_SELECTOR)) {
        return true;
      }
    }
  }
  return false;
}

export async function sendLiquidation(
  chainId: number,
  chainRpc: string,
  pk: `0x${string}`,
  contract: Address,
  planArgs: Parameters<typeof encodePlan>[0],
  privateRpc?: string,
) {
  const writeRpc = privateRpc ?? chainRpc;
  const w = wallet(writeRpc, pk);
  const pub = createPublicClient({ transport: http(chainRpc) });

  const data = {
    abi: LiquidatorAbi,
    address: contract,
    ...encodePlan(planArgs),
  } as const;

  // Estimate then send
  const gas = await instrument('rpc', 'estimateContractGas', async () => {
    try {
      return await pub.estimateContractGas({ account: w.account, ...data });
    } catch (err) {
      if (isHealthFactorError(err)) {
        throw new Error(HEALTH_FACTOR_ERROR);
      }
      throw err;
    }
  });

  return instrument('rpc', 'writeContract', async () => {
    try {
      const chain = CHAINS[chainId];
      if (!chain) throw new Error(`Unsupported chainId for sender: ${chainId}`);
      return await w.writeContract({ ...data, gas, chain });
    } catch (err) {
      if (isHealthFactorError(err)) {
        throw new Error(HEALTH_FACTOR_ERROR);
      }
      throw err;
    }
  });
}

===== END liquidator/offchain/executor/send_tx.ts =====

===== BEGIN liquidator/offchain/executor/Liquidator.abi.json =====
[
  {
    "type": "function",
    "name": "liquidateWithFlash",
    "stateMutability": "nonpayable",
    "inputs": [
      {
        "name": "p",
        "type": "tuple",
        "components": [
          { "name": "borrower", "type": "address" },
          { "name": "debtAsset", "type": "address" },
          { "name": "collateralAsset", "type": "address" },
          { "name": "repayAmount", "type": "uint256" },
          { "name": "dexId", "type": "uint8" },
          { "name": "router", "type": "address" },
          { "name": "uniFee", "type": "uint24" },
          { "name": "solidlyStable", "type": "bool" },
          { "name": "solidlyFactory", "type": "address" },
          { "name": "minProfit", "type": "uint256" },
          { "name": "amountOutMin", "type": "uint256" },
          { "name": "deadline", "type": "uint256" },
          { "name": "path", "type": "bytes" }
        ]
      }
    ],
    "outputs": [],
    "anonymous": false
  },
  {
    "type": "function",
    "name": "liquidateWithFunds",
    "stateMutability": "nonpayable",
    "inputs": [
      {
        "name": "p",
        "type": "tuple",
        "components": [
          { "name": "borrower", "type": "address" },
          { "name": "debtAsset", "type": "address" },
          { "name": "collateralAsset", "type": "address" },
          { "name": "repayAmount", "type": "uint256" },
          { "name": "dexId", "type": "uint8" },
          { "name": "router", "type": "address" },
          { "name": "uniFee", "type": "uint24" },
          { "name": "solidlyStable", "type": "bool" },
          { "name": "solidlyFactory", "type": "address" },
          { "name": "minProfit", "type": "uint256" },
          { "name": "amountOutMin", "type": "uint256" },
          { "name": "deadline", "type": "uint256" },
          { "name": "path", "type": "bytes" }
        ]
      }
    ],
    "outputs": [],
    "anonymous": false
  },
  { "type": "function", "name": "setPaused", "stateMutability": "nonpayable", "inputs": [{"name": "p","type": "bool"}], "outputs": [] },
  { "type": "function", "name": "setBeneficiary", "stateMutability": "nonpayable", "inputs": [{"name": "b","type": "address"}], "outputs": [] },
  { "type": "function", "name": "setRouterAllowed", "stateMutability": "nonpayable", "inputs": [{"name": "r","type": "address"},{"name":"a","type":"bool"}], "outputs": [] }
]

===== END liquidator/offchain/executor/Liquidator.abi.json =====

===== BEGIN liquidator/offchain/indexer/aave_indexer.ts =====
// Aave v3 subgraph driven candidate discovery for near-liquidation accounts
import { log } from '../infra/logger';
import { AppConfig, ChainCfg } from '../infra/config';
import { emitAlert } from '../infra/alerts';

export type Candidate = {
  borrower: `0x${string}`;
  chainId: number;
  debt: { symbol: string; address: `0x${string}`; decimals: number; amount: bigint };
  collateral: { symbol: string; address: `0x${string}`; decimals: number; amount: bigint };
  healthFactor: number;
};

export const SUBGRAPH_ENV_KEYS: Record<number, string> = {
  42161: 'AAVE_V3_SUBGRAPH_ARB',
  10: 'AAVE_V3_SUBGRAPH_OP',
  8453: 'AAVE_V3_SUBGRAPH_BASE',
  137: 'AAVE_V3_SUBGRAPH_POLYGON',
};

const SUBGRAPH_IDS: Record<number, string> = {
  42161: 'DLuE98kEb5pQNXAcKFQGQgfSQ57Xdou4jnVbAEqMfy3B',
  10: 'DSfLz8oQBUeU5atALgUFQKMTSYV9mZAVYp4noLSXAfvb',
  8453: 'GQFbb95cE6d8mV989mL5figjaGaKCQB3xqYrr1bRyXqF',
  137: 'Co2URyXjnxaw8WqxKyVHdirq9Ahhm5vcTs4dMedAq211',
};

const FALLBACK_SUBGRAPH_URL: Record<number, string> = {
  42161: 'https://api.thegraph.com/subgraphs/name/aave/protocol-v3-arbitrum',
  10: 'https://api.thegraph.com/subgraphs/name/aave/protocol-v3-optimism',
  8453: '',
  137: '',
};

export function buildSubgraphUrl(chainId: number): string {
  const envKey = SUBGRAPH_ENV_KEYS[chainId];
  const override = envKey ? process.env[envKey] : undefined;
  if (override && !override.includes('MISSING')) return override;
  const apiKey = process.env.GRAPH_API_KEY?.trim();
  const id = SUBGRAPH_IDS[chainId];
  if (apiKey && id) {
    return `https://gateway.thegraph.com/api/${apiKey}/subgraphs/id/${id}`;
  }
  return FALLBACK_SUBGRAPH_URL[chainId] ?? '';
}

// Query for reserves tied to users with health factor below a certain threshold.
const QUERY_USER_RESERVES_BY_HF = `
  query GetUserReservesByHealthFactor($first: Int!) {
    userReserves(
      first: $first,
      orderBy: user__borrowedReservesCount,
      orderDirection: desc,
      where: {
        user_: { borrowedReservesCount_gt: 0 }
      }
    ) {
      user {
        id
      }
      reserve {
        id
        symbol
        decimals
        underlyingAsset
        reserveLiquidationThreshold
        price {
          priceInEth
        }
      }
      usageAsCollateralEnabledOnUser
      currentTotalDebt
      currentATokenBalance
    }
  }
`;

type SubgraphUserReserve = {
  user: {
    id: string;
  };
  reserve: {
    id: string;
    symbol: string;
    decimals: number;
    underlyingAsset?: string;
    reserveLiquidationThreshold?: string;
    price?: {
      priceInEth?: string;
    };
  };
  usageAsCollateralEnabledOnUser: boolean;
  currentTotalDebt?: string;
  currentATokenBalance?: string;
};

const QUERY_USER_RESERVES_BY_USER = `
  query GetUserReservesByUser($user: String!) {
    userReserves(
      where: {
        user: $user
        currentTotalDebt_not: "0"
      }
    ) {
      user {
        id
      }
      reserve {
        id
        symbol
        decimals
        underlyingAsset
        reserveLiquidationThreshold
        price {
          priceInEth
        }
      }
      usageAsCollateralEnabledOnUser
      currentTotalDebt
      currentATokenBalance
    }
  }
`;

const PRICE_SCALE = 100_000_000n; // priceInEth precision (1e8)
const LIQ_THRESHOLD_SCALE = 10_000n;
const AUTH_ERROR_REGEX = /(payment required|auth error|unauthorized|invalid api key|does not exist)/i;
const AUTH_ALERT_COOLDOWN_MS = 10 * 60 * 1000;
const lastAuthAlert = new Map<string, number>();

function getIndexerSettings(cfg: AppConfig) {
  const rawPoll = cfg.indexer?.pollMs ?? 500;
  const rawDedupe = cfg.indexer?.dedupeMs ?? 5 * 60 * 1000;
  const rawFirst = cfg.indexer?.subgraphFirst ?? 500;
  const rawThreshold = cfg.indexer?.hfThreshold ?? 1.1;

  return {
    pollMs: Math.max(50, rawPoll),
    hfThreshold: Math.max(1.0, rawThreshold),
    dedupeMs: Math.max(5_000, rawDedupe),
    subgraphFirst: Math.max(1, Math.min(rawFirst, 1000)),
  };
}

export async function graphFetch<T = any>(url: string, query: string, variables: Record<string, any>): Promise<T> {
  const headers: Record<string, string> = { 'content-type': 'application/json' };
  const apiKey = process.env.GRAPH_API_KEY?.trim();
  if (apiKey) headers.authorization = `Bearer ${apiKey}`;

  const res = await fetch(url, {
    method: 'POST',
    headers,
    body: JSON.stringify({
      query,
      variables,
    }),
  });

  if (!res.ok) {
    const text = await res.text();
    throw new Error(`subgraph http ${res.status}: ${text}`);
  }

  const json = (await res.json()) as { data?: any; errors?: any };
  if (json.errors) {
    throw new Error(`subgraph error: ${JSON.stringify(json.errors)}`);
  }
  return json.data as T;
}

export function parseBigIntOrZero(v: string | undefined): bigint {
  try {
    return v ? BigInt(v) : 0n;
  } catch {
    return 0n;
  }
}

export type UserReserveBucket = {
  reserves: SubgraphUserReserve[];
  totalDebtEth: bigint;
  totalAdjustedCollateralEth: bigint;
};

export function normalizeAddress(addr: string | undefined): `0x${string}` | null {
  if (!addr) return null;
  if (addr.startsWith('0x') && addr.length === 42) {
    return addr.toLowerCase() as `0x${string}`;
  }
  const parts = addr.split('-');
  const candidate = parts[parts.length - 1];
  if (candidate?.startsWith('0x') && candidate.length === 42) {
    return candidate.toLowerCase() as `0x${string}`;
  }
  return null;
}

export function groupUserReserves(reserves: SubgraphUserReserve[]): Map<string, UserReserveBucket> {
  const grouped = new Map<string, UserReserveBucket>();
  for (const reserve of reserves) {
    const userId = reserve.user?.id;
    if (!userId?.startsWith('0x')) continue;
    if (!grouped.has(userId)) {
      grouped.set(userId, { reserves: [], totalDebtEth: 0n, totalAdjustedCollateralEth: 0n });
    }
    const bucket = grouped.get(userId)!;
    bucket.reserves.push(reserve);

    const priceRaw = reserve.reserve.price?.priceInEth;
    const priceInEth = parseBigIntOrZero(priceRaw);
    if (priceInEth === 0n) continue;

    const decimals = typeof reserve.reserve.decimals === 'number' ? reserve.reserve.decimals : Number(reserve.reserve.decimals ?? 0);
    const unit = 10n ** BigInt(decimals);

    const debtBalance = parseBigIntOrZero(reserve.currentTotalDebt);
    if (debtBalance > 0n) {
      const debtEth = (debtBalance * priceInEth) / (unit * PRICE_SCALE);
      bucket.totalDebtEth += debtEth;
    }

    if (reserve.usageAsCollateralEnabledOnUser) {
      const collateralBalance = parseBigIntOrZero(reserve.currentATokenBalance);
      if (collateralBalance > 0n) {
        const collateralEth = (collateralBalance * priceInEth) / (unit * PRICE_SCALE);
        if (collateralEth > 0n) {
          const threshold = parseBigIntOrZero(reserve.reserve.reserveLiquidationThreshold);
          const adjusted = (collateralEth * threshold) / LIQ_THRESHOLD_SCALE;
          bucket.totalAdjustedCollateralEth += adjusted;
        }
      }
    }
  }
  return grouped;
}

export function buildCandidatesFromBucket(
  userId: string,
  chainId: number,
  bucket: UserReserveBucket,
  hfThreshold: number
): Candidate[] {
  const healthFactor = bucket.totalDebtEth === 0n
    ? Number.POSITIVE_INFINITY
    : Number((bucket.totalAdjustedCollateralEth * 1_000_000n) / bucket.totalDebtEth) / 1_000_000;
  if (!Number.isFinite(healthFactor) || healthFactor <= 0 || healthFactor >= hfThreshold) return [];

  const debts: Candidate['debt'][] = [];
  const collaterals: Candidate['collateral'][] = [];

  for (const reserve of bucket.reserves) {
    const address = normalizeAddress(reserve.reserve.underlyingAsset ?? reserve.reserve.id);
    if (!address) continue;
    const decimalsRaw = reserve.reserve.decimals;
    const decimals = typeof decimalsRaw === 'number' ? decimalsRaw : Number(decimalsRaw ?? 0);
    const symbol = reserve.reserve.symbol;

    const debtAmount = parseBigIntOrZero(reserve.currentTotalDebt);
    if (debtAmount > 0n) {
      debts.push({ symbol, address, decimals, amount: debtAmount });
    }

    const collateralAmount = parseBigIntOrZero(reserve.currentATokenBalance);
    if (reserve.usageAsCollateralEnabledOnUser && collateralAmount > 0n) {
      collaterals.push({ symbol, address, decimals, amount: collateralAmount });
    }
  }

  const out: Candidate[] = [];
  for (const debt of debts) {
    for (const collateral of collaterals) {
      if (debt.address === collateral.address) continue;
      out.push({
        borrower: userId as `0x${string}`,
        chainId,
        healthFactor,
        debt,
        collateral,
      });
    }
  }
  return out;
}

function delay(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

export async function* streamCandidates(cfg: AppConfig): AsyncGenerator<Candidate> {
  const dedupe = new Map<string, number>();
  const { dedupeMs, pollMs, subgraphFirst, hfThreshold } = getIndexerSettings(cfg);
  const pageSize = subgraphFirst;
  while (true) {
    for (const chain of cfg.chains.filter((c) => c.enabled)) {
      const subgraph = buildSubgraphUrl(chain.id);
      if (!subgraph) continue;

      try {
        const t0 = Date.now();
        const response = await graphFetch<{ userReserves: SubgraphUserReserve[] }>(subgraph, QUERY_USER_RESERVES_BY_HF, {
          first: pageSize,
        });
        const reserves = response?.userReserves ?? [];
        const dt = Date.now() - t0;
        log.debug({ chainId: chain.id, userReserves: reserves.length, ms: dt, subgraph }, 'subgraph-poll-hf');

        const grouped = groupUserReserves(reserves);
        for (const [userId, bucket] of grouped.entries()) {
          const candidates = buildCandidatesFromBucket(userId, chain.id, bucket, hfThreshold);
          for (const candidate of candidates) {
            // Deduplicate candidates to avoid processing the same one too frequently
            const key = `${candidate.chainId}:${candidate.borrower}:${candidate.debt.address}:${candidate.collateral.address}`;
            const now = Date.now();
            const last = dedupe.get(key) ?? 0;
            if (now - last < dedupeMs) continue;
            dedupe.set(key, now);
            yield candidate;
          }
        }
      } catch (err) {
        const message = err instanceof Error ? err.message : String(err);
        log.warn({ err: message, chainId: chain.id, subgraph }, 'aave-indexer-failed');

        if (AUTH_ERROR_REGEX.test(message)) {
          const key = `${chain.id}:${subgraph}`;
          const now = Date.now();
          const last = lastAuthAlert.get(key) ?? 0;
          if (now - last >= AUTH_ALERT_COOLDOWN_MS) {
            lastAuthAlert.set(key, now);
            await emitAlert(
              'Aave subgraph auth error',
              { chainId: chain.id, subgraph, message },
              'critical'
            );
          }
        }
      }
    }

    await delay(pollMs);
  }
}

export async function fetchBorrowerCandidates(
  cfg: AppConfig,
  chain: ChainCfg,
  borrower: `0x${string}`
): Promise<Candidate[]> {
  const subgraph = buildSubgraphUrl(chain.id);
  if (!subgraph) return [];

  const userId = borrower.toLowerCase();
  const { hfThreshold } = getIndexerSettings(cfg);
  try {
    const response = await graphFetch<{ userReserves: SubgraphUserReserve[] }>(
      subgraph,
      QUERY_USER_RESERVES_BY_USER,
      { user: userId }
    );
    const reserves = response?.userReserves ?? [];
    if (reserves.length === 0) return [];
    const grouped = groupUserReserves(reserves);
    const bucket = grouped.get(userId);
    if (!bucket) return [];
    return buildCandidatesFromBucket(userId, chain.id, bucket, hfThreshold);
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    log.debug({ chainId: chain.id, borrower: userId, err: message }, 'fetch-borrower-candidates-failed');
    return [];
  }
}

export async function pollChainCandidatesOnce(
  cfg: AppConfig,
  chain: ChainCfg,
  first = 500
): Promise<Candidate[]> {
  const subgraph = buildSubgraphUrl(chain.id);
  if (!subgraph) return [];
  const out: Candidate[] = [];

  const { subgraphFirst, hfThreshold } = getIndexerSettings(cfg);
  const limit = subgraphFirst || first;

  try {
    const response = await graphFetch<{ userReserves: SubgraphUserReserve[] }>(
      subgraph,
      QUERY_USER_RESERVES_BY_HF,
      { first: limit }
    );
    const reserves = response?.userReserves ?? [];
    const grouped = groupUserReserves(reserves);
    for (const [userId, bucket] of grouped.entries()) {
      const candidates = buildCandidatesFromBucket(userId, chain.id, bucket, hfThreshold);
      for (const candidate of candidates) {
        out.push(candidate);
      }
    }
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    log.debug({ chainId: chain.id, err: message }, 'poll-chain-candidates-failed');
  }

  return out;
}

===== END liquidator/offchain/indexer/aave_indexer.ts =====

===== BEGIN liquidator/offchain/indexer/price_watcher.ts =====
import type { Address, Chain, PublicClient, Transport } from 'viem';
import { ChainCfg, TokenInfo } from '../infra/config';
import { bestRoute, RouteOption } from '../simulator/router';

type RpcClient = PublicClient<Transport, Chain | undefined, any>;

const ORACLE_TTL_MS = 24 * 60 * 60 * 1000; // 24 hours – stablecoin feeds on L2 can stay flat for long stretches
const ROUTE_TTL_MS = 5_000;

type OracleObservation = {
  feed: string | null;
  priceUsd: number | null;
  decimals: number | null;
  updatedAt: number | null;
  stale: boolean;
  rawAnswer?: string;
  answeredInRound?: string;
  error?: string;
};

type OracleCacheEntry = {
  value: OracleObservation | undefined;
  expires: number;
  pending?: Promise<OracleObservation>;
};

type RouteCacheEntry = {
  value: Awaited<ReturnType<typeof bestRoute>> | undefined;
  expires: number;
  pending?: Promise<Awaited<ReturnType<typeof bestRoute>> | undefined>;
};

const oracleCache = new Map<string, OracleCacheEntry>();
const routeCache = new Map<string, RouteCacheEntry>();

function cacheKeyOracle(token: TokenInfo): string | undefined {
  if (!token.chainlinkFeed) return undefined;
  return token.chainlinkFeed.toLowerCase();
}

function cacheKeyRoute(chain: ChainCfg, collateral: TokenInfo, debt: TokenInfo, router: string, fee: number): string {
  return `${chain.id}:${router.toLowerCase()}:${collateral.address.toLowerCase()}:${debt.address.toLowerCase()}:${fee}`;
}

export type OraclePriceDetail = OracleObservation & {
  ageSeconds: number | null;
  hasFeed: boolean;
};

async function loadOracleDetail(client: RpcClient, token: TokenInfo): Promise<OracleObservation> {
  const feed = token.chainlinkFeed as Address;
  try {
    const decimals = (await client.readContract({
      address: feed,
      abi: FEED_ABI,
      functionName: 'decimals',
      args: [],
    })) as number;

    const [roundId, answer, , updatedAt, answeredInRound] = (await client.readContract({
      address: feed,
      abi: FEED_ABI,
      functionName: 'latestRoundData',
      args: [],
    })) as [bigint, bigint, bigint, bigint, bigint];

    const now = BigInt(Math.floor(Date.now() / 1000));
    const ttlSeconds = BigInt(Math.max(1, Math.floor(ORACLE_TTL_MS / 1000)));
    const stale =
      answer <= 0n ||
      updatedAt === 0n ||
      now - updatedAt > ttlSeconds ||
      answeredInRound < roundId;

    const priceUsd = stale ? null : Number(answer) / 10 ** decimals;

    return {
      feed,
      priceUsd,
      decimals,
      updatedAt: Number(updatedAt),
      stale,
      rawAnswer: answer.toString(),
      answeredInRound: answeredInRound.toString(),
    };
  } catch (err) {
    return {
      feed,
      priceUsd: null,
      decimals: null,
      updatedAt: null,
      stale: true,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

async function cachedOracleDetail(client: RpcClient, token: TokenInfo): Promise<OracleObservation> {
  if (!token.chainlinkFeed) {
    return {
      feed: token.chainlinkFeed ?? null,
      priceUsd: null,
      decimals: null,
      updatedAt: null,
      stale: true,
      error: 'missing-feed',
    };
  }

  const key = cacheKeyOracle(token)!;
  const now = Date.now();
  const entry = oracleCache.get(key);
  if (entry && entry.expires > now && entry.pending === undefined && entry.value) {
    return entry.value;
  }
  if (entry?.pending) {
    return entry.pending;
  }
  const pending = loadOracleDetail(client, token).then((value) => {
    oracleCache.set(key, { value, expires: Date.now() + ORACLE_TTL_MS });
    return value;
  });
  oracleCache.set(key, { value: entry?.value, expires: entry?.expires ?? 0, pending });
  return pending;
}

async function cachedOraclePrice(client: RpcClient, token: TokenInfo): Promise<number | undefined> {
  const detail = await cachedOracleDetail(client, token);
  return detail.priceUsd === null ? undefined : detail.priceUsd;
}

async function cachedBestRoute(params: {
  client: RpcClient;
  chain: ChainCfg;
  collateral: TokenInfo;
  debt: TokenInfo;
  fee: number;
  router?: string;
  unitIn: bigint;
}): Promise<Awaited<ReturnType<typeof bestRoute>> | undefined> {
  const { client, chain, collateral, debt, fee, router, unitIn } = params;
  const routerAddr = router ?? chain.uniV3Router;
  if (!routerAddr) return undefined;
  const key = cacheKeyRoute(chain, collateral, debt, routerAddr, fee);
  const now = Date.now();
  const entry = routeCache.get(key);
  if (entry && entry.expires > now && entry.pending === undefined) {
    return entry.value;
  }
  if (entry?.pending) {
    return entry.pending;
  }
  const options: RouteOption[] = [
    { type: 'UniV3', router: routerAddr as Address, fee },
  ];
  const pending = bestRoute({
    client,
    chain,
    collateral,
    debt,
    seizeAmount: unitIn,
    slippageBps: 0,
    options,
  })
    .then((value) => {
      routeCache.set(key, { value, expires: Date.now() + ROUTE_TTL_MS });
      return value;
    })
    .catch(() => {
      routeCache.delete(key);
      return undefined;
    });
  routeCache.set(key, { value: entry?.value, expires: entry?.expires ?? 0, pending });
  return pending;
}

// Minimal AggregatorV3Interface ABI (Chainlink)
const FEED_ABI = [
  {
    type: 'function',
    name: 'decimals',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ internalType: 'uint8', name: '', type: 'uint8' }],
  },
  {
    type: 'function',
    name: 'latestRoundData',
    stateMutability: 'view',
    inputs: [],
    outputs: [
      { internalType: 'uint80', name: 'roundId', type: 'uint80' },
      { internalType: 'int256', name: 'answer', type: 'int256' },
      { internalType: 'uint256', name: 'startedAt', type: 'uint256' },
      { internalType: 'uint256', name: 'updatedAt', type: 'uint256' },
      { internalType: 'uint80', name: 'answeredInRound', type: 'uint80' },
    ],
  },
] as const;

function toNumber(amount: bigint, decimals: number): number {
  const base = 10n ** BigInt(decimals);
  const integer = amount / base;
  const fraction = amount % base;
  return Number(integer) + Number(fraction) / Number(base);
}

export async function oraclePriceUsd(client: RpcClient, token: TokenInfo): Promise<number | undefined> {
  return cachedOraclePrice(client, token);
}

export async function oraclePriceDetails(client: RpcClient, token: TokenInfo): Promise<OraclePriceDetail> {
  const observation = await cachedOracleDetail(client, token);
  const updatedAt = observation.updatedAt;
  const ageSeconds = updatedAt ? Math.max(0, Math.floor(Date.now() / 1000) - updatedAt) : null;
  return {
    ...observation,
    ageSeconds,
    hasFeed: Boolean(observation.feed ?? token.chainlinkFeed),
  };
}

export async function oracleDexGapBps({
  client,
  chain,
  collateral,
  debt,
  fee,
  router,
}: {
  client: RpcClient;
  chain: ChainCfg;
  collateral: TokenInfo;
  debt: TokenInfo;
  fee: number;
  router?: string;
}): Promise<number> {
  const collateralPriceUsd = await cachedOraclePrice(client, collateral);
  const debtPriceUsd = (await cachedOraclePrice(client, debt)) ?? 1;

  const oraclePrice = collateralPriceUsd !== undefined ? collateralPriceUsd / debtPriceUsd : undefined;

  const unitIn = 10n ** BigInt(Math.min(collateral.decimals, 18));
  const route = await cachedBestRoute({ client, chain, collateral, debt, fee, router, unitIn });
  if (!route) return 0;

  const dexPrice = toNumber(route.quotedOut, debt.decimals) / toNumber(unitIn, collateral.decimals);

  if (!oraclePrice || oraclePrice === 0) {
    return 0;
  }

  const diff = Math.abs(dexPrice - oraclePrice);
  return Math.round((diff / oraclePrice) * 10_000);
}

===== END liquidator/offchain/indexer/price_watcher.ts =====

===== BEGIN liquidator/offchain/realtime/watchers.ts =====
import { Address, createPublicClient, http } from 'viem';
import assert from 'assert';
import type { ChainCfg, AppConfig } from '../infra/config';
import { log } from '../infra/logger';
import { getPoolFromProvider } from '../infra/aave_provider';
import {
  Candidate,
  fetchBorrowerCandidates,
  pollChainCandidatesOnce,
} from '../indexer/aave_indexer';
import { invalidateOracleFeed } from '../indexer/price_watcher';
import { recordFeedUpdate } from './oracle_predictor';

const watchRealtimeEnv = process.env.WATCH_REALTIME;
const WATCH_FLAG =
  watchRealtimeEnv === undefined ? true : watchRealtimeEnv.toLowerCase() === 'true';
const BASE_POLL_INTERVAL_MS = Number(process.env.WATCH_POLL_MS ?? 500);
const MAX_POLL_INTERVAL_MS = Number(process.env.WATCH_MAX_POLL_MS ?? 5_000);
const RATE_LIMIT_BACKOFF_MS = Number(process.env.WATCH_RATE_LIMIT_BACKOFF_MS ?? 10_000);
const MAX_RATE_LIMIT_BACKOFF_MS = Number(process.env.WATCH_MAX_RATE_LIMIT_BACKOFF_MS ?? 60_000);
const BORROWER_DEBOUNCE_MS = 750;
const PRICE_REFETCH_DEBOUNCE_MS = 2_000;

const POOL_EVENTS_ABI = [
  {
    type: 'event',
    name: 'Borrow',
    inputs: [
      { name: 'reserve', type: 'address', indexed: true },
      { name: 'user', type: 'address', indexed: false },
      { name: 'onBehalfOf', type: 'address', indexed: true },
      { name: 'amount', type: 'uint256', indexed: false },
      { name: 'interestRateMode', type: 'uint8', indexed: false },
      { name: 'borrowRate', type: 'uint256', indexed: false },
      { name: 'referralCode', type: 'uint16', indexed: false },
    ],
  },
  {
    type: 'event',
    name: 'Repay',
    inputs: [
      { name: 'reserve', type: 'address', indexed: true },
      { name: 'user', type: 'address', indexed: true },
      { name: 'repayer', type: 'address', indexed: true },
      { name: 'amount', type: 'uint256', indexed: false },
      { name: 'useATokens', type: 'bool', indexed: false },
    ],
  },
  {
    type: 'event',
    name: 'Supply',
    inputs: [
      { name: 'reserve', type: 'address', indexed: true },
      { name: 'user', type: 'address', indexed: true },
      { name: 'onBehalfOf', type: 'address', indexed: true },
      { name: 'amount', type: 'uint256', indexed: false },
      { name: 'referralCode', type: 'uint16', indexed: false },
    ],
  },
  {
    type: 'event',
    name: 'Withdraw',
    inputs: [
      { name: 'reserve', type: 'address', indexed: true },
      { name: 'user', type: 'address', indexed: true },
      { name: 'to', type: 'address', indexed: true },
      { name: 'amount', type: 'uint256', indexed: false },
    ],
  },
  {
    type: 'event',
    name: 'LiquidationCall',
    inputs: [
      { name: 'collateralAsset', type: 'address', indexed: true },
      { name: 'debtAsset', type: 'address', indexed: true },
      { name: 'user', type: 'address', indexed: true },
      { name: 'debtToCover', type: 'uint256', indexed: false },
      { name: 'liquidatedCollateralAmount', type: 'uint256', indexed: false },
      { name: 'liquidator', type: 'address', indexed: false },
      { name: 'receiveAToken', type: 'bool', indexed: false },
    ],
  },
] as const;

const AGGREGATOR_ABI = [
  {
    type: 'event',
    name: 'AnswerUpdated',
    inputs: [
      { name: 'current', type: 'int256', indexed: true },
      { name: 'roundId', type: 'uint256', indexed: true },
      { name: 'updatedAt', type: 'uint256', indexed: false },
    ],
  },
] as const;

const AGGREGATOR_PROXY_ABI = [
  {
    type: 'function',
    name: 'aggregator',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ type: 'address' }],
  },
] as const;

export type RealtimeCandidate = Candidate & {
  __source: 'realtime';
  __trigger: string;
};

class CandidateQueue {
  private items: RealtimeCandidate[] = [];
  private waiters: Array<{ resolve: (value: RealtimeCandidate) => void; reject: (err: Error) => void }> = [];
  private closed = false;

  push(item: RealtimeCandidate) {
    if (this.closed) return;
    const waiter = this.waiters.shift();
    if (waiter) {
      waiter.resolve(item);
    } else {
      this.items.push(item);
    }
  }

  tryShift(): RealtimeCandidate | null {
    return this.items.shift() ?? null;
  }

  next(): Promise<RealtimeCandidate> {
    if (this.closed) {
      return Promise.reject(new Error('queue closed'));
    }
    const immediate = this.tryShift();
    if (immediate) {
      return Promise.resolve(immediate);
    }
    return new Promise((resolve, reject) => {
      this.waiters.push({ resolve, reject });
    });
  }

  shutdown(error = new Error('queue closed')) {
    if (this.closed) return;
    this.closed = true;
    for (const waiter of this.waiters.splice(0)) {
      waiter.reject(error);
    }
    this.items = [];
  }
}

export interface ChainRealtimeWatcher {
  next(): Promise<RealtimeCandidate>;
  tryShift(): RealtimeCandidate | null;
  stop(): void;
}

function resolveBorrowerFromEvent(args: Record<string, any>): Address | null {
  if (args.user && typeof args.user === 'string') return args.user as Address;
  if (args.onBehalfOf && typeof args.onBehalfOf === 'string') return args.onBehalfOf as Address;
  return null;
}

async function fetchAndEnqueueBorrower(
  cfg: AppConfig,
  chain: ChainCfg,
  borrower: Address,
  trigger: string,
  queue: CandidateQueue
) {
  const candidates = await fetchBorrowerCandidates(cfg, chain, borrower);
  for (const candidate of candidates) {
    queue.push({ ...(candidate as Candidate), __source: 'realtime', __trigger: trigger });
  }
}

async function refetchChainCandidates(
  cfg: AppConfig,
  chain: ChainCfg,
  trigger: string,
  queue: CandidateQueue
) {
  const candidates = await pollChainCandidatesOnce(cfg, chain);
  for (const candidate of candidates) {
    queue.push({ ...(candidate as Candidate), __source: 'realtime', __trigger: trigger });
  }
}

class ChainWatcher implements ChainRealtimeWatcher {
  private queue = new CandidateQueue();
  private unwatchers: Array<() => void> = [];
  private borrowerSeenAt = new Map<string, number>();
  private lastPriceRefetch = 0;
  private stopped = false;
  private client?: ReturnType<typeof createPublicClient>;
  private pool?: Address;
  private currentPollMs = BASE_POLL_INTERVAL_MS;
  private backoffMs = RATE_LIMIT_BACKOFF_MS;
  private rateLimitedUntil = 0;
  private restartTimer: NodeJS.Timeout | null = null;
  private lastRateLimitAt = 0;

  constructor(private chain: ChainCfg, private cfg: AppConfig) {}

  async start() {
    if (!WATCH_FLAG) return;
    this.client = createPublicClient({ transport: http(this.chain.rpc) });
    let pool: Address;
    try {
      pool = await getPoolFromProvider(this.chain.rpc, this.chain.aaveProvider);
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err);
      log.warn({ chain: this.chain.id, err: message }, 'realtime-pool-lookup-failed');
      return;
    }
    this.pool = pool;

    await this.startWatchers();
  }

  private async startWatchers(): Promise<void> {
    if (!WATCH_FLAG || this.stopped) return;
    if (!this.client || !this.pool) return;
    if (this.unwatchers.length > 0) return;

    this.rateLimitedUntil = 0;

    const client = this.client;
    const pollingInterval = Math.min(Math.max(this.currentPollMs, BASE_POLL_INTERVAL_MS), MAX_POLL_INTERVAL_MS);

    const allowedEvents = new Set(['Borrow', 'Repay', 'Supply', 'Withdraw', 'LiquidationCall']);

    const unwatchPool = client.watchContractEvent({
      address: this.pool,
      abi: POOL_EVENTS_ABI,
      pollingInterval,
      onError: (err) => {
        this.handleWatcherError('pool', err);
      },
      onLogs: (logs) => {
        this.onWatcherActivity();
        for (const logItem of logs) {
          const eventName = String(logItem.eventName ?? '');
          if (!allowedEvents.has(eventName)) continue;
          const borrower = resolveBorrowerFromEvent(logItem.args ?? {});
          if (!borrower) continue;
          const key = borrower.toLowerCase();
          const now = Date.now();
          const last = this.borrowerSeenAt.get(key) ?? 0;
          if (now - last < BORROWER_DEBOUNCE_MS) continue;
          this.borrowerSeenAt.set(key, now);
          void fetchAndEnqueueBorrower(this.cfg, this.chain, borrower, `pool:${eventName}`, this.queue);
        }
      },
    });
    this.unwatchers.push(unwatchPool);

    const proxyToAgg = new Map<string, string>();
    const aggregators = new Set<string>();
    for (const token of Object.values(this.chain.tokens ?? {})) {
      const proxy = token.chainlinkFeed?.toLowerCase();
      if (!proxy) continue;
      try {
        const agg = (await client.readContract({
          address: proxy as Address,
          abi: AGGREGATOR_PROXY_ABI,
          functionName: 'aggregator',
        })) as Address;
        const aggLc = agg.toLowerCase();
        proxyToAgg.set(proxy, aggLc);
        aggregators.add(aggLc);
      } catch (err) {
        log.debug({ chain: this.chain.id, feed: proxy, err: (err as Error).message }, 'aggregator-proxy-fallback');
        proxyToAgg.set(proxy, proxy);
        aggregators.add(proxy);
      }
    }

    for (const aggregator of aggregators) {
      const unwatchFeed = client.watchContractEvent({
        address: aggregator as Address,
        abi: AGGREGATOR_ABI,
        eventName: 'AnswerUpdated',
        pollingInterval,
        onError: (err) => {
          this.handleWatcherError('feed', err, { feed: aggregator });
        },
        onLogs: (logs) => {
          const now = Date.now();
          if (now - this.lastPriceRefetch < PRICE_REFETCH_DEBOUNCE_MS) return;
          let tickTimestamp = now;
          if (logs.length > 0) {
            const first = logs[logs.length - 1];
            const raw = (first.args as any)?.updatedAt ?? (first.args as any)?.[2];
            if (typeof raw === 'bigint') {
              const asNumber = Number(raw);
              if (Number.isFinite(asNumber) && asNumber > 0) {
                tickTimestamp = asNumber * 1000;
              }
            }
          }
          this.lastPriceRefetch = now;
          this.onWatcherActivity();
          for (const [proxy, agg] of proxyToAgg.entries()) {
            if (agg === aggregator) {
              invalidateOracleFeed(proxy);
              recordFeedUpdate(proxy, tickTimestamp);
            }
          }
          // TODO: surface price magnitude in trigger so policy can tighten when volatility spikes.
          void refetchChainCandidates(this.cfg, this.chain, `price:${aggregator}`, this.queue);
        },
      });
      this.unwatchers.push(unwatchFeed);
    }
  }

  private onWatcherActivity() {
    if (this.stopped) return;
    if (this.restartTimer) {
      clearTimeout(this.restartTimer);
      this.restartTimer = null;
    }
    if (Date.now() - this.lastRateLimitAt > this.backoffMs) {
      this.backoffMs = RATE_LIMIT_BACKOFF_MS;
    }
    if (this.currentPollMs > BASE_POLL_INTERVAL_MS) {
      this.currentPollMs = Math.max(BASE_POLL_INTERVAL_MS, Math.floor(this.currentPollMs / 2));
    }
  }

  private handleWatcherError(kind: 'pool' | 'feed', err: unknown, metadata: Record<string, unknown> = {}) {
    if (this.isRateLimitError(err)) {
      this.applyRateLimit(kind, metadata);
      return;
    }
    const message = err instanceof Error ? err.message : String(err);
    log.warn({ chain: this.chain.id, kind, err: message, ...metadata }, 'realtime-watch-error');
  }

  private isRateLimitError(err: unknown): boolean {
    const message = err instanceof Error ? err.message : String(err ?? '');
    if (!message) return false;
    return message.includes('429') || /too many requests/i.test(message);
  }

  private applyRateLimit(kind: 'pool' | 'feed', metadata: Record<string, unknown>) {
    const now = Date.now();
    if (now < this.rateLimitedUntil) {
      return;
    }
    this.lastRateLimitAt = now;
    this.rateLimitedUntil = now + this.backoffMs;
    log.warn({
      chain: this.chain.id,
      kind,
      pollMs: this.currentPollMs,
      backoffMs: this.backoffMs,
      ...metadata,
    }, 'realtime-rate-limited');
    this.clearWatchers();
    if (this.restartTimer) {
      clearTimeout(this.restartTimer);
    }
    const delay = this.backoffMs;
    const nextPoll = Math.min(this.currentPollMs * 2, MAX_POLL_INTERVAL_MS);
    const nextBackoff = Math.min(this.backoffMs * 2, MAX_RATE_LIMIT_BACKOFF_MS);
    this.currentPollMs = nextPoll;
    this.backoffMs = nextBackoff;
    this.restartTimer = setTimeout(() => {
      this.restartTimer = null;
      if (this.stopped) return;
      this.clearWatchers();
      void this.startWatchers();
    }, delay);
  }

  private clearWatchers() {
    for (const unwatch of this.unwatchers) {
      try {
        unwatch();
      } catch (err) {
        log.warn({ chain: this.chain.id, err: (err as Error).message }, 'realtime-unwatch-failed');
      }
    }
    this.unwatchers = [];
  }

  next(): Promise<RealtimeCandidate> {
    return this.queue.next();
  }

  tryShift(): RealtimeCandidate | null {
    return this.queue.tryShift();
  }

  stop() {
    if (this.stopped) return;
    this.stopped = true;
    if (this.restartTimer) {
      clearTimeout(this.restartTimer);
      this.restartTimer = null;
    }
    this.clearWatchers();
    this.queue.shutdown(new Error('realtime watcher stopped'));
  }
}

export async function createChainWatcher(chain: ChainCfg, cfg: AppConfig): Promise<ChainRealtimeWatcher | null> {
  if (!WATCH_FLAG) return null;
  assert(chain.enabled, 'chain must be enabled for realtime watcher');
  const watcher = new ChainWatcher(chain, cfg);
  await watcher.start();
  return watcher;
}

===== END liquidator/offchain/realtime/watchers.ts =====

===== BEGIN liquidator/offchain/simulator/gas.ts =====
import type { Address, Chain, PublicClient, Transport } from 'viem';

const FEED_ABI = [
  { type: 'function', name: 'decimals', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint8' }] },
  {
    type: 'function',
    name: 'latestRoundData',
    stateMutability: 'view',
    inputs: [],
    outputs: [
      { type: 'uint80', name: 'roundId' },
      { type: 'int256', name: 'answer' },
      { type: 'uint256', name: 'startedAt' },
      { type: 'uint256', name: 'updatedAt' },
      { type: 'uint80', name: 'answeredInRound' },
    ],
  },
] as const;

type RpcClient = PublicClient<Transport, Chain | undefined, any>;

async function readFeedUsd(client: RpcClient, feed?: Address, maxStalenessMs = 15_000): Promise<number | undefined> {
  if (!feed) return undefined;
  try {
    const decimals = (await client.readContract({ address: feed, abi: FEED_ABI, functionName: 'decimals' })) as number;
    const result = (await client.readContract({ address: feed, abi: FEED_ABI, functionName: 'latestRoundData' })) as [
      bigint,
      bigint,
      bigint,
      bigint,
      bigint,
    ];
    const answer = result[1];
    const updatedAt = result[3];
    const now = BigInt(Math.floor(Date.now() / 1000));
    if (answer <= 0n || updatedAt === 0n || now - updatedAt > BigInt(Math.floor(maxStalenessMs / 1000))) return undefined;
    return Number(answer) / 10 ** decimals;
  } catch {
    return undefined;
  }
}

export async function estimateGasUsd(
  client: RpcClient,
  chain: { id: number; name: string; rpc: string; tokens: Record<string, { chainlinkFeed?: Address }> },
  gasUnitsHint: bigint = 550_000n
): Promise<number> {
  let weiPerGas: bigint;
  try {
    const fees = await client.estimateFeesPerGas();
    const maxFeePerGas = (fees as any).maxFeePerGas as bigint | undefined;
    const gasPrice = (fees as any).gasPrice as bigint | undefined;
    if (maxFeePerGas && maxFeePerGas > 0n) {
      weiPerGas = maxFeePerGas;
    } else if (gasPrice && gasPrice > 0n) {
      weiPerGas = gasPrice;
    } else {
      weiPerGas = await client.getGasPrice();
    }
  } catch {
    weiPerGas = await client.getGasPrice();
  }

  const wethFeed = chain.tokens?.WETH?.chainlinkFeed as Address | undefined;
  const nativeUsd = await readFeedUsd(client, wethFeed);

  const gasEth = Number(weiPerGas) / 1e18 * Number(gasUnitsHint);
  if (nativeUsd && nativeUsd > 0) {
    return gasEth * nativeUsd;
  }

  return Math.max(0.2, gasEth * 2000);
}

===== END liquidator/offchain/simulator/gas.ts =====

===== BEGIN liquidator/offchain/simulator/router.ts =====
import type { Chain, PublicClient, Transport } from 'viem';
import { Address, getAddress } from 'viem';
import { ChainCfg, TokenInfo } from '../infra/config';

export const DEX_ID = {
  UNI_V3: 0,
  SOLIDLY_V2: 1,
  UNI_V2: 2,
  UNI_V3_MULTI: 3,
} as const;

export type RouteOption =
  | { type: 'UniV3'; router: Address; fee: number }
  | { type: 'SolidlyV2'; router: Address; factory: Address; stable: boolean }
  | { type: 'UniV2'; router: Address }
  | { type: 'UniV3Multi'; router: Address; path: Address[]; fees: number[] };

export type RouteQuote = {
  dexId: number;
  router: Address;
  uniFee?: number;
  solidlyStable?: boolean;
  solidlyFactory?: Address;
  path?: `0x${string}`;
  fees?: number[];
  amountOutMin: bigint;
  quotedOut: bigint;
};

type RpcClient = PublicClient<Transport, Chain | undefined, any>;

const QUOTER_ABI = [
  {
    name: 'quoteExactInputSingle',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [
      {
        name: 'params',
        type: 'tuple',
        components: [
          { name: 'tokenIn', type: 'address' },
          { name: 'tokenOut', type: 'address' },
          { name: 'amountIn', type: 'uint256' },
          { name: 'fee', type: 'uint24' },
          { name: 'sqrtPriceLimitX96', type: 'uint160' },
        ],
      },
    ],
    outputs: [
      { name: 'amountOut', type: 'uint256' },
      { name: 'sqrtPriceX96After', type: 'uint160' },
      { name: 'initializedTicksCrossed', type: 'uint32' },
      { name: 'gasEstimate', type: 'uint256' },
    ],
  },
  {
    name: 'quoteExactInput',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [
      {
        name: 'params',
        type: 'tuple',
        components: [
          { name: 'path', type: 'bytes' },
          { name: 'amountIn', type: 'uint256' },
        ],
      },
    ],
    outputs: [
      { name: 'amountOut', type: 'uint256' },
      { name: 'sqrtPriceX96AfterList', type: 'uint160[]' },
      { name: 'initializedTicksCrossedList', type: 'uint32[]' },
      { name: 'gasEstimate', type: 'uint256' },
    ],
  },
] as const;

const UNI_V2_ABI = [
  {
    name: 'getAmountsOut',
    type: 'function',
    stateMutability: 'view',
    inputs: [
      { name: 'amountIn', type: 'uint256' },
      { name: 'path', type: 'address[]' },
    ],
    outputs: [{ name: 'amounts', type: 'uint256[]' }],
  },
] as const;

const SOLIDLY_ABI = [
  {
    name: 'getAmountsOut',
    type: 'function',
    stateMutability: 'view',
    inputs: [
      { name: 'amountIn', type: 'uint256' },
      {
        name: 'routes',
        type: 'tuple[]',
        components: [
          { name: 'from', type: 'address' },
          { name: 'to', type: 'address' },
          { name: 'stable', type: 'bool' },
          { name: 'factory', type: 'address' },
        ],
      },
    ],
    outputs: [{ name: 'amounts', type: 'uint256[]' }],
  },
] as const;

function encodeUniV3Path(tokens: Address[], fees: number[]): `0x${string}` {
  if (tokens.length !== fees.length + 1) {
    throw new Error('invalid path');
  }
  const parts: number[] = [];
  for (let i = 0; i < fees.length; i += 1) {
    const token = tokens[i];
    const fee = fees[i];
    const tokenBytes = token.toLowerCase().replace(/^0x/, '');
    if (tokenBytes.length !== 40) throw new Error('token length');
    for (let j = 0; j < tokenBytes.length; j += 2) {
      parts.push(parseInt(tokenBytes.slice(j, j + 2), 16));
    }
    const feeHex = fee.toString(16).padStart(6, '0');
    for (let j = 0; j < feeHex.length; j += 2) {
      parts.push(parseInt(feeHex.slice(j, j + 2), 16));
    }
  }
  const lastToken = tokens[tokens.length - 1].toLowerCase().replace(/^0x/, '');
  if (lastToken.length !== 40) throw new Error('token length');
  for (let j = 0; j < lastToken.length; j += 2) {
    parts.push(parseInt(lastToken.slice(j, j + 2), 16));
  }
  return (`0x${Buffer.from(parts).toString('hex')}`) as `0x${string}`;
}

async function quoteUniV3(
  client: RpcClient,
  chain: ChainCfg,
  option: Extract<RouteOption, { type: 'UniV3' }>,
  collateral: TokenInfo,
  debt: TokenInfo,
  seizeAmount: bigint
): Promise<bigint> {
  const { result } = await client.simulateContract({
    address: getAddress(chain.quoter as Address),
    abi: QUOTER_ABI,
    functionName: 'quoteExactInputSingle',
    args: [
      {
        tokenIn: getAddress(collateral.address as Address),
        tokenOut: getAddress(debt.address as Address),
        amountIn: seizeAmount,
        fee: option.fee,
        sqrtPriceLimitX96: 0n,
      },
    ],
  });
  const [amountOut] = result as unknown as [bigint, bigint, number, bigint];
  return amountOut;
}

async function quoteUniV3Multi(
  client: RpcClient,
  chain: ChainCfg,
  option: Extract<RouteOption, { type: 'UniV3Multi' }>,
  seizeAmount: bigint
): Promise<{ quoted: bigint; path: `0x${string}` }> {
  const encodedPath = encodeUniV3Path(option.path, option.fees);
  const { result } = await client.simulateContract({
    address: getAddress(chain.quoter as Address),
    abi: QUOTER_ABI,
    functionName: 'quoteExactInput',
    args: [
      {
        path: encodedPath,
        amountIn: seizeAmount,
      },
    ],
  });
  const [amountOut] = result as unknown as [bigint, bigint[], number[], bigint];
  return { quoted: amountOut, path: encodedPath };
}

async function quoteUniV2(
  client: RpcClient,
  option: Extract<RouteOption, { type: 'UniV2' }>,
  collateral: TokenInfo,
  debt: TokenInfo,
  seizeAmount: bigint
): Promise<bigint> {
  const path = [collateral.address, debt.address];
  const amounts = (await client.readContract({
    address: getAddress(option.router),
    abi: UNI_V2_ABI,
    functionName: 'getAmountsOut',
    args: [seizeAmount, path],
  })) as bigint[];
  return amounts[amounts.length - 1];
}

async function quoteSolidlyV2(
  client: RpcClient,
  option: Extract<RouteOption, { type: 'SolidlyV2' }>,
  collateral: TokenInfo,
  debt: TokenInfo,
  seizeAmount: bigint
): Promise<bigint> {
  const routes = [
    {
      from: collateral.address,
      to: debt.address,
      stable: option.stable,
      factory: option.factory,
    },
  ];
  const amounts = (await client.readContract({
    address: getAddress(option.router),
    abi: SOLIDLY_ABI,
    functionName: 'getAmountsOut',
    args: [seizeAmount, routes],
  })) as bigint[];
  return amounts[amounts.length - 1];
}

export async function bestRoute({
  client,
  chain,
  collateral,
  debt,
  seizeAmount,
  slippageBps,
  options,
}: {
  client: RpcClient;
  chain: ChainCfg;
  collateral: TokenInfo;
  debt: TokenInfo;
  seizeAmount: bigint;
  slippageBps: number;
  options: RouteOption[];
}): Promise<RouteQuote | null> {
  if (seizeAmount === 0n || options.length === 0) {
    return null;
  }

  let best: RouteQuote | null = null;

  for (const option of options) {
    try {
      let quoted: bigint;
      let quotePath: `0x${string}` | undefined;
      if (option.type === 'UniV3') {
        quoted = await quoteUniV3(client, chain, option, collateral, debt, seizeAmount);
      } else if (option.type === 'SolidlyV2') {
        quoted = await quoteSolidlyV2(client, option, collateral, debt, seizeAmount);
      } else if (option.type === 'UniV2') {
        quoted = await quoteUniV2(client, option, collateral, debt, seizeAmount);
      } else {
        const multi = await quoteUniV3Multi(client, chain, option, seizeAmount);
        quoted = multi.quoted;
        quotePath = multi.path;
      }

      const amountOutMin = (quoted * BigInt(10_000 - slippageBps)) / 10_000n;
      const quote: RouteQuote = {
        dexId:
          option.type === 'UniV3'
            ? DEX_ID.UNI_V3
            : option.type === 'SolidlyV2'
            ? DEX_ID.SOLIDLY_V2
            : option.type === 'UniV2'
            ? DEX_ID.UNI_V2
            : DEX_ID.UNI_V3_MULTI,
        router: option.router,
        uniFee: option.type === 'UniV3' ? option.fee : undefined,
        solidlyStable: option.type === 'SolidlyV2' ? option.stable : undefined,
        solidlyFactory: option.type === 'SolidlyV2' ? option.factory : undefined,
        path: quotePath,
        fees: option.type === 'UniV3Multi' ? option.fees : undefined,
        amountOutMin,
        quotedOut: quoted,
      };

      if (!best || quoted > best.quotedOut) {
        best = quote;
      }
    } catch {
      // soft-fail and continue
      continue;
    }
  }

  return best;
}

===== END liquidator/offchain/simulator/router.ts =====

===== BEGIN liquidator/offchain/simulator/simulate.ts =====
import type { Address, Chain, PublicClient, Transport } from 'viem';
import { BaseError, ContractFunctionRevertedError } from 'viem';
import { ChainCfg, TokenInfo } from '../infra/config';
import { bestRoute, RouteOption } from './router';
import { encodePlan } from '../executor/build_tx';
import LiquidatorAbi from '../executor/Liquidator.abi.json';

type RpcClient = PublicClient<Transport, Chain | undefined, any>;

export type TokenPosition = TokenInfo & { symbol: string; amount: bigint };

export type SimInput = {
  client: RpcClient;
  chain: ChainCfg;
  debt: TokenPosition;
  collateral: TokenPosition;
  closeFactor: number; // 0..1
  bonusBps: number; // liquidation bonus e.g. 800
  routes: RouteOption[];
  pricesUsd: { debt: number; coll: number };
  policy: { floorBps: number; gapCapBps: number; slippageBps: number };
  gasCapUsd: number;
  maxRepayUsd?: number;
  contract: Address;
  beneficiary: Address;
  executor: Address;
  borrower: Address;
};

export type Plan = {
  repayAmount: bigint;
  seizeAmount: bigint;
  repayUsd: number;
  dexId: number;
  router: Address;
  uniFee: number;
  solidlyStable?: boolean;
  solidlyFactory?: Address;
  amountOutMin: bigint;
  estNetBps: number;
  gasUsd: number;
  path: `0x${string}`;
  mode?: 'flash' | 'funds';
  precommit?: boolean;
};

const HEALTH_FACTOR_ERROR = 'HealthFactorNotBelowThreshold';
const HEALTH_FACTOR_SELECTOR = '0x930bb771';

function toNumber(amount: bigint, decimals: number): number {
  const base = 10n ** BigInt(decimals);
  const integer = amount / base;
  const fraction = amount % base;
  return Number(integer) + Number(fraction) / Number(base);
}

function applyBps(amount: bigint, bps: number): bigint {
  return (amount * BigInt(bps)) / 10_000n;
}

async function estimateGas(
  client: RpcClient,
  chain: ChainCfg,
  contract: Address,
  executor: Address,
  plan: any
): Promise<number | null> {
  const data = {
    abi: LiquidatorAbi,
    address: contract,
    ...encodePlan(plan),
  } as const;

  let gas: bigint;
  try {
    gas = await client.estimateContractGas({ account: executor, ...data });
  } catch (err) {
    if (err instanceof BaseError) {
      const revert = err.walk((error) => error instanceof ContractFunctionRevertedError);
      if (revert instanceof ContractFunctionRevertedError) {
        const errorName = revert.data?.errorName ?? (revert as any).errorName;
        if (errorName === HEALTH_FACTOR_ERROR) {
          return null;
        }
        const signature =
          (revert.data as any)?.errorSignature ??
          (revert.data as any)?.signature ??
          (revert as any).signature;
        if (signature === HEALTH_FACTOR_SELECTOR) {
          return null;
        }
        const raw = (revert.data as any)?.data ?? (revert as any).data;
        if (typeof raw === 'string' && raw.startsWith(HEALTH_FACTOR_SELECTOR)) {
          return null;
        }
      }
    }
    throw err;
  }
  const fees = await client.estimateFeesPerGas();
  const maxFeePerGas = (fees as any).maxFeePerGas as bigint | undefined;
  const gasPrice = (fees as any).gasPrice as bigint | undefined;
  let weiPerGas: bigint;
  if (maxFeePerGas && maxFeePerGas > 0n) {
    weiPerGas = maxFeePerGas;
  } else if (gasPrice && gasPrice > 0n) {
    weiPerGas = gasPrice;
  } else {
    weiPerGas = await client.getGasPrice();
  }

  const gasEth = Number(weiPerGas) / 1e18 * Number(gas);
  return gasEth;
}

export async function simulate(input: SimInput): Promise<Plan | null> {
  if (input.pricesUsd.debt <= 0 || input.pricesUsd.coll <= 0) {
    return null;
  }

  const cfBps = Math.floor(input.closeFactor * 10_000);
  if (cfBps <= 0) return null;

  let repay = applyBps(input.debt.amount, cfBps);
  if (repay === 0n) return null;

  const pow10 = Math.pow(10, input.debt.decimals);
  if (!Number.isFinite(pow10) || pow10 <= 0) return null;

  const toTokensNumber = (amount: bigint) => toNumber(amount, input.debt.decimals);
  let repayTokens = toTokensNumber(repay);
  let repayUsd = repayTokens * input.pricesUsd.debt;

  if (input.maxRepayUsd !== undefined && input.maxRepayUsd > 0 && repayUsd > input.maxRepayUsd) {
    const maxRepayTokens = input.maxRepayUsd / input.pricesUsd.debt;
    if (!Number.isFinite(maxRepayTokens) || maxRepayTokens <= 0) return null;
    const maxRepayAmount = BigInt(Math.floor(maxRepayTokens * pow10));
    if (maxRepayAmount <= 0n) return null;
    repay = maxRepayAmount < repay ? maxRepayAmount : repay;
    repayTokens = toTokensNumber(repay);
    repayUsd = repayTokens * input.pricesUsd.debt;
    if (repay <= 0n || repayUsd <= 0) return null;
  }

  const bonusFactor = 1 + input.bonusBps / 10_000;
  const seizeUsd = repayUsd * bonusFactor;
  if (seizeUsd <= 0) return null;

  const seizeTokens = seizeUsd / input.pricesUsd.coll;
  const seizeAmount = (() => {
    const seizePow = Math.pow(10, input.collateral.decimals);
    if (!Number.isFinite(seizePow) || seizePow <= 0) return 0n;
    const raw = BigInt(Math.floor(seizeTokens * seizePow));
    return raw > input.collateral.amount ? input.collateral.amount : raw;
  })();
  if (seizeAmount === 0n) return null;

  const route = await bestRoute({
    client: input.client,
    chain: input.chain,
    collateral: input.collateral,
    debt: input.debt,
    seizeAmount,
    slippageBps: input.policy.slippageBps,
    options: input.routes,
  });

  if (!route) return null;

  const minProfit = (repay * BigInt(input.policy.floorBps)) / 10_000n;
  const deadline = BigInt(Math.floor(Date.now() / 1000) + 300);

  const gasEth = await estimateGas(input.client, input.chain, input.contract, input.executor, {
    borrower: input.borrower,
    debtAsset: input.debt.address,
    collateralAsset: input.collateral.address,
    repayAmount: repay,
    dexId: route.dexId,
    router: route.router,
    uniFee: route.uniFee ?? 0,
    solidlyStable: route.solidlyStable,
    solidlyFactory: route.solidlyFactory,
    minProfit,
    amountOutMin: route.amountOutMin,
    deadline,
    path: route.path ?? '0x',
  });

  if (gasEth === null) {
    return null;
  }

  const gasUsd = gasEth * input.pricesUsd.debt; // Assuming debt is a stablecoin
  if (gasUsd > input.gasCapUsd) {
    return null;
  }

  const proceedsUsd = toNumber(route.amountOutMin, input.debt.decimals) * input.pricesUsd.debt;
  const costsUsd = repayUsd + gasUsd;
  const netUsd = proceedsUsd - costsUsd;
  const estNetBps = repayUsd > 0 ? (netUsd / repayUsd) * 10_000 : 0;

  if (estNetBps < input.policy.floorBps) return null;

  return {
    repayAmount: repay,
    seizeAmount,
    repayUsd,
    dexId: route.dexId,
    router: route.router,
    uniFee: route.uniFee ?? 0,
    solidlyStable: route.solidlyStable,
    solidlyFactory: route.solidlyFactory,
    amountOutMin: route.amountOutMin,
    estNetBps,
    gasUsd,
    path: route.path ?? '0x',
  };
}

===== END liquidator/offchain/simulator/simulate.ts =====

===== BEGIN liquidator/offchain/infra/env.ts =====
import fs from 'fs';
import path from 'path';
import dotenv from 'dotenv';
import dotenvExpand from 'dotenv-expand';

// Load .env from project root (../.. from this file) or current working dir fallback
const ROOT = path.resolve(__dirname, '..', '..');
const CANDIDATES = [
  path.join(ROOT, '.env'),               // liquidator/.env (preferred)
  path.resolve(ROOT, '..', '.env'),      // repo root .env fallback
];

for (const p of CANDIDATES) {
  if (fs.existsSync(p)) {
    const result = dotenv.config({ path: p, override: true });
    dotenvExpand.expand(result as any);
    break;
  }
}

// Minimal validation for critical vars (non-fatal warnings only)
function warn(name: string) {
  if (!process.env[name] || /\$\{.*\}/.test(process.env[name] as string)) {
    console.warn(`[env] WARN missing or unexpanded var: ${name}`);
  }
}

['RPC_ARB','WALLET_PK_ARB','SAFE_ADDRESS_ARB','DATABASE_URL','REDIS_URL'].forEach(warn);

===== END liquidator/offchain/infra/env.ts =====

===== BEGIN liquidator/offchain/infra/config.ts =====
import fs from 'fs';
import YAML from 'yaml';
import { log } from './logger';

export type TokenInfo = {
  address: `0x${string}`;
  decimals: number;
  chainlinkFeed?: `0x${string}`;
};

export type ChainCfg = {
  id: number;
  name: string;
  rpc: string;
  privtx?: string;
  aaveProvider: `0x${string}`;
  uniV3Router: `0x${string}`;
  quoter: `0x${string}`;
  sequencerFeed?: `0x${string}`;
  enabled: boolean;
  tokens: Record<string, TokenInfo>;
};

export type DexRouterEntry = {
  uniV3?: `0x${string}`;
  camelotV2?: `0x${string}`;
  velodrome?: `0x${string}`;
  velodromeFactory?: `0x${string}`;
  aerodrome?: `0x${string}`;
  aerodromeFactory?: `0x${string}`;
  tokens?: Record<string, `0x${string}`>;
  [key: string]: any;
};

export type AssetPolicy = { floorBps: number; gapCapBps: number; slippageBps: number };
export type Market = {
  protocol: 'aavev3';
  chainId: number;
  debtAsset: string;
  collateralAsset: string;
  closeFactorBps?: number;
  bonusBps?: number;
  enabled: boolean;
};

export type AppConfig = {
  beneficiary?: `0x${string}`;
  contracts?: {
    liquidator?: Record<number, `0x${string}`>;
  };
  chains: ChainCfg[];
  assets: Record<string, AssetPolicy>;
  markets: Market[];
  risk: {
    gasCapUsd: number;
    failRateCap: number;
    pnlPerGasMin: number;
    maxAttemptsPerBorrowerHour: number;
    dryRun: boolean;
    maxRepayUsd?: number;
    maxLiveExecutions?: number;
    maxSessionNotionalUsd?: number;
    healthFactorMax?: number;
    denyAssets?: string[];
  };
  indexer?: {
    subgraphFirst?: number;
    dedupeMs?: number;
    pollMs?: number;
    hfThreshold?: number;
  };
  routing: any;
  dexRouters?: Record<number, DexRouterEntry>;
  analysis?: {
    openaiKey?: string;
  };
};

function interpolateString(s: string): string {
  return s.replace(/\$\{([A-Z0-9_]+)\}/g, (_, name) => {
    const val = process.env[name];
    return val !== undefined ? val : ` MISSING:${name} `;
  });
}

function interpolateEnv<T = any>(obj: T): T {
  if (obj == null) return obj;
  if (typeof obj === 'string') return interpolateString(obj) as any;
  if (Array.isArray(obj)) return obj.map((v) => interpolateEnv(v)) as any;
  if (typeof obj === 'object') {
    const out: any = Array.isArray(obj) ? [] : {};
    for (const [k, v] of Object.entries(obj as any)) {
      out[k] = interpolateEnv(v);
    }
    return out;
  }
  return obj;
}

export function loadConfig(path = 'config.yaml'): AppConfig {
  const raw = fs.readFileSync(path, 'utf8');
  const parsed = YAML.parse(raw);
  const cfg = interpolateEnv(parsed);
  // Optional: warn if any placeholders remained missing
  const asJson = JSON.stringify(cfg);
  if (asJson.includes('\u0000MISSING:')) {
    log.warn({}, 'config-missing-env-placeholders');
  }
  return cfg as AppConfig;
}

export function chainById(cfg: AppConfig, chainId: number): ChainCfg | undefined {
  return cfg.chains.find((c) => c.id === chainId);
}

export function liquidatorForChain(cfg: AppConfig, chainId: number): `0x${string}` | undefined {
  return cfg.contracts?.liquidator?.[chainId];
}

===== END liquidator/offchain/infra/config.ts =====

===== BEGIN liquidator/offchain/infra/logger.ts =====
import { mkdirSync } from 'fs';
import { resolve } from 'path';
import pino, { TransportMultiOptions } from 'pino';

type Target = TransportMultiOptions['targets'][number];

const level = process.env.LOG_LEVEL || 'info';
const targets: Target[] = [];

function parseSize(input: string | undefined, fallback: number): number {
	if (!input) return fallback;
	const match = /^\s*(\d+(?:\.\d+)?)([kKmMgG]?[bB]?)?\s*$/.exec(input);
	if (!match) return fallback;
	const value = Number(match[1]);
	if (!Number.isFinite(value) || value <= 0) return fallback;
	const unit = match[2]?.toLowerCase() ?? '';
	switch (unit.replace('b', '')) {
		case 'k':
			return Math.floor(value * 1024);
		case 'm':
			return Math.floor(value * 1024 * 1024);
		case 'g':
			return Math.floor(value * 1024 * 1024 * 1024);
		default:
			return Math.floor(value);
	}
}

function parseIntEnv(input: string | undefined, fallback: number): number {
	const parsed = Number.parseInt(input ?? '', 10);
	return Number.isInteger(parsed) && parsed > 0 ? parsed : fallback;
}

if (process.env.LOG_DISABLE_STDOUT !== '1') {
	targets.push({
		target: 'pino/file',
		options: { destination: 1 },
		level,
	});
}

const logDir = process.env.LOG_DIR
	? resolve(process.cwd(), process.env.LOG_DIR)
	: resolve(process.cwd(), 'logs');
const logFileName = process.env.LOG_FILE_NAME ?? 'live.log';
const logMaxBytes = parseSize(process.env.LOG_MAX_BYTES, 20 * 1024 * 1024);
const logMaxFiles = parseIntEnv(process.env.LOG_MAX_FILES, 10);

try {
	mkdirSync(logDir, { recursive: true });
	targets.push({
		target: resolve(__dirname, './rolling-log-target.js'),
		options: {
			dir: logDir,
			baseName: logFileName,
			maxBytes: logMaxBytes,
			maxFiles: logMaxFiles,
		},
		level,
	});
} catch (err) {
	console.warn('logger-file-init-failed', (err as Error).message);
}

const transport = targets.length > 0 ? pino.transport({ targets }) : undefined;

export const log = transport ? pino({ level }, transport) : pino({ level });

===== END liquidator/offchain/infra/logger.ts =====

===== BEGIN liquidator/offchain/infra/rolling-log-target.js =====
'use strict';

const { Writable } = require('stream');
const {
  mkdirSync,
  createWriteStream,
  existsSync,
  renameSync,
  statSync,
  readdirSync,
  unlinkSync,
} = require('fs');
const { join, resolve } = require('path');

class RollingFileStream extends Writable {
  constructor(options = {}) {
    super();
    this.dir = resolve(process.cwd(), options.dir ?? 'logs');
    this.baseName = options.baseName ?? 'live.log';
    this.maxBytes = typeof options.maxBytes === 'number' && options.maxBytes > 0
      ? options.maxBytes
      : 20 * 1024 * 1024; // 20 MB default
    this.maxFiles = Number.isInteger(options.maxFiles) && options.maxFiles > 1
      ? options.maxFiles
      : 10; // archived files to keep in addition to active

    mkdirSync(this.dir, { recursive: true });
    this.currentPath = join(this.dir, this.baseName);
    this.stream = createWriteStream(this.currentPath, { flags: 'a' });
    this.currentSize = this._safeSize(this.currentPath);
  }

  _safeSize(path) {
    try {
      return statSync(path).size;
    } catch (err) {
      return 0;
    }
  }

  _write(chunk, encoding, callback) {
    const size = this._chunkSize(chunk, encoding);
    if (this.currentSize + size > this.maxBytes) {
      try {
        this._rotate();
      } catch (err) {
        callback(err);
        return;
      }
    }

    if (!this.stream.write(chunk, encoding)) {
      this.stream.once('drain', () => {
        this.currentSize += size;
        callback();
      });
      return;
    }

    this.currentSize += size;
    callback();
  }

  _chunkSize(chunk, encoding) {
    if (Buffer.isBuffer(chunk)) return chunk.length;
    const enc = encoding && encoding !== 'buffer' ? encoding : 'utf8';
    return Buffer.byteLength(String(chunk), enc);
  }

  _rotate() {
    if (this.stream) {
      this.stream.end();
    }

    if (existsSync(this.currentPath) && this.currentSize > 0) {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const prefix = this.baseName.endsWith('.log')
        ? this.baseName.slice(0, -4)
        : this.baseName;
      const rotatedPath = join(this.dir, `${prefix}-${timestamp}.log`);
      try {
        renameSync(this.currentPath, rotatedPath);
      } catch (err) {
        // If rename fails, continue writing to avoid losing logs
        this.stream = createWriteStream(this.currentPath, { flags: 'a' });
        return;
      }
      this._trimArchives();
    }

    this.stream = createWriteStream(this.currentPath, { flags: 'a' });
    this.currentSize = this._safeSize(this.currentPath);
  }

  _trimArchives() {
    if (!this.maxFiles || this.maxFiles <= 1) return;

    const prefix = this.baseName.endsWith('.log')
      ? this.baseName.slice(0, -4)
      : this.baseName;

    const files = readdirSync(this.dir)
      .filter((name) => name.startsWith(`${prefix}-`) && name.endsWith('.log'))
      .map((name) => ({
        name,
        mtime: this._safeMTime(join(this.dir, name)),
      }))
      .sort((a, b) => b.mtime - a.mtime);

    const retain = this.maxFiles - 1; // keep newest N archives; active file counts separately
    const excess = files.slice(retain);
    for (const file of excess) {
      try {
        unlinkSync(join(this.dir, file.name));
      } catch (err) {
        // ignore deletion errors
      }
    }
  }

  _safeMTime(path) {
    try {
      return statSync(path).mtimeMs;
    } catch (err) {
      return 0;
    }
  }

  _final(callback) {
    if (this.stream) {
      this.stream.end(() => callback());
      return;
    }
    callback();
  }
}

module.exports = function rollingFileTransport(options) {
  return new RollingFileStream(options);
};

===== END liquidator/offchain/infra/rolling-log-target.js =====

===== BEGIN liquidator/offchain/infra/metrics.ts =====
import client from 'prom-client';

export const registry = new client.Registry();
client.collectDefaultMetrics({ register: registry });

export const gauge = {
  pnlPerGas: new client.Gauge({ name: 'pnl_per_gas', help: 'PnL per gas unit' }),
  hitRate: new client.Gauge({ name: 'hit_rate', help: 'simulated to sent ratio' }),
};
registry.registerMetric(gauge.pnlPerGas);
registry.registerMetric(gauge.hitRate);

export const histogram = {
  dbQueryDuration: new client.Histogram({
    name: 'db_query_duration_seconds',
    help: 'Duration of database queries in seconds',
    labelNames: ['operation', 'status'],
  }),
  rpcCallDuration: new client.Histogram({
    name: 'rpc_call_duration_seconds',
    help: 'Duration of RPC calls in seconds',
    labelNames: ['operation', 'status'],
  }),
};
registry.registerMetric(histogram.dbQueryDuration);
registry.registerMetric(histogram.rpcCallDuration);

export const counter = {
  candidates: new client.Counter({ name: 'candidates_total', help: 'Total liquidation candidates processed', labelNames: ['chain'] }),
  throttled: new client.Counter({ name: 'candidates_throttled_total', help: 'Candidates skipped due to throttle window', labelNames: ['chain'] }),
  gapSkip: new client.Counter({ name: 'candidates_gap_skip_total', help: 'Candidates skipped due to oracle-DEX gap', labelNames: ['chain'] }),
  sequencerSkip: new client.Counter({ name: 'candidates_sequencer_skip_total', help: 'Candidates skipped due to sequencer downtime or stale feed', labelNames: ['chain'] }),
  denylistSkip: new client.Counter({ name: 'candidates_denylist_skip_total', help: 'Candidates skipped due to asset denylist', labelNames: ['chain'] }),
  plansReady: new client.Counter({ name: 'plans_ready_total', help: 'Plans produced by simulator', labelNames: ['chain'] }),
  plansDryRun: new client.Counter({ name: 'plans_dry_run_total', help: 'Plans recorded in dry-run mode', labelNames: ['chain'] }),
  plansSent: new client.Counter({ name: 'plans_sent_total', help: 'Transactions submitted on-chain', labelNames: ['chain'] }),
  plansError: new client.Counter({ name: 'plans_error_total', help: 'Errors while processing candidate', labelNames: ['chain'] }),
  dbErrors: new client.Counter({ name: 'db_errors_total', help: 'Total database errors' }),
  rpcErrors: new client.Counter({ name: 'rpc_errors_total', help: 'Total RPC errors' }),
};
Object.values(counter).forEach((metric) => registry.registerMetric(metric));

===== END liquidator/offchain/infra/metrics.ts =====

===== BEGIN liquidator/offchain/infra/metrics_server.ts =====
import http from 'http';
import { registry } from './metrics';

const srv = http.createServer(async (req, res) => {
  if (req.url === '/metrics') {
    try {
      const data = await registry.metrics();
      res.writeHead(200, { 'Content-Type': registry.contentType });
      return res.end(data);
    } catch (e) {
      res.writeHead(500); return res.end((e as Error).message);
    }
  }
  if (req.url === '/live' || req.url === '/ready') {
    res.writeHead(200); return res.end('ok');
  }
  res.writeHead(404); res.end();
});

srv.listen(process.env.PROM_PORT || 9464);

===== END liquidator/offchain/infra/metrics_server.ts =====

===== BEGIN liquidator/offchain/infra/db.ts =====
import { Pool } from 'pg';
import { instrument } from './instrument';

const dbPool = new Pool({ connectionString: process.env.DATABASE_URL });

export const db = {
  query: <T extends unknown[]>(
    queryTextOrConfig: string | any,
    values?: T,
  ): Promise<any> => {
    const queryName = typeof queryTextOrConfig === 'string' ? queryTextOrConfig.split(' ')[0].toLowerCase() : queryTextOrConfig.name || 'unknown';
    return instrument('db', queryName, () => dbPool.query(queryTextOrConfig, values));
  },
  end: () => dbPool.end(),
};
===== END liquidator/offchain/infra/db.ts =====

===== BEGIN liquidator/offchain/infra/instrument.ts =====
import { histogram, counter } from './metrics';

type OperationType = 'db' | 'rpc';

export async function instrument<T>(
  operationType: OperationType,
  name: string,
  operation: () => Promise<T>,
): Promise<T> {
  const metric =
    operationType === 'db'
      ? histogram.dbQueryDuration
      : histogram.rpcCallDuration;
  const errorCounter =
    operationType === 'db' ? counter.dbErrors : counter.rpcErrors;

  const end = metric.startTimer();
  const labels = {
    operation: name,
  };

  try {
    const result = await operation();
    end({ ...labels, status: 'success' });
    return result;
  } catch (error) {
    end({ ...labels, status: 'error' });
    errorCounter.inc();
    throw error;
  }
}

===== END liquidator/offchain/infra/instrument.ts =====

===== BEGIN liquidator/offchain/infra/alerts.ts =====
import { log } from './logger';

type AlertLevel = 'info' | 'warn' | 'critical';

const slackWebhook = process.env.SLACK_WEBHOOK_URL;
const pagerDutyKey = process.env.PAGERDUTY_API_KEY;

async function postJson(url: string, payload: unknown) {
  try {
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify(payload),
    });
    if (!res.ok) {
      const text = await res.text();
      log.warn({ url, status: res.status, text }, 'alert-post-failed');
    }
  } catch (err) {
    log.warn({ err: (err as Error).message }, 'alert-post-exception');
  }
}

export async function sendSlackAlert(title: string, details: Record<string, unknown>, level: AlertLevel = 'warn') {
  if (!slackWebhook) return;
  const meta = Object.entries(details)
    .map(([k, v]) => `• *${k}*: ${v}`)
    .join('\n');
  const emoji = level === 'critical' ? ':rotating_light:' : level === 'warn' ? ':warning:' : ':information_source:';
  await postJson(slackWebhook, {
    text: `${emoji} ${title}\n${meta}`,
  });
}

export async function sendPagerDutyAlert(title: string, details: Record<string, unknown>, level: AlertLevel = 'warn') {
  if (!pagerDutyKey) return;
  const severity = level === 'warn' ? 'warning' : level;
  await postJson('https://events.pagerduty.com/v2/enqueue', {
    routing_key: pagerDutyKey,
    event_action: 'trigger',
    payload: {
      summary: title,
      source: 'l2-liquidator',
      severity,
      custom_details: details,
    },
  });
}

export async function emitAlert(title: string, details: Record<string, unknown>, level: AlertLevel = 'warn') {
  log.warn({ title, details, level }, 'alert');

  const alerts = [sendSlackAlert(title, details, level)];
  if (level === 'critical') {
    alerts.push(sendPagerDutyAlert(title, details, level));
  }
  await Promise.all(alerts);
}

===== END liquidator/offchain/infra/alerts.ts =====

===== BEGIN liquidator/offchain/infra/aave_provider.ts =====
import { Address, createPublicClient, http, getAddress } from 'viem';
import type { AppConfig } from './config';
import { instrument } from './instrument';
import { log } from './logger';

const PROVIDER_ABI = [
  {
    type: 'function',
    name: 'getPool',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ name: '', type: 'address' }],
  },
] as const;

export async function getPoolFromProvider(rpc: string, provider: Address): Promise<Address> {
  return instrument('rpc', 'getPoolFromProvider', async () => {
    const client = createPublicClient({ transport: http(rpc) });
    const normalized = getAddress(provider);
    const pool = await client.readContract({ abi: PROVIDER_ABI, address: normalized, functionName: 'getPool' });
    return pool as Address;
  });
}

export async function logPoolsAtBoot(cfg: AppConfig): Promise<void> {
  for (const chain of cfg.chains) {
    if (!chain.enabled || !('aaveProvider' in chain) || !chain.aaveProvider) continue;
    try {
      const pool = await getPoolFromProvider(chain.rpc, chain.aaveProvider as Address);
      log.info({ chainId: chain.id, provider: chain.aaveProvider, pool }, 'aave-provider-pool');
    } catch (err) {
      log.warn({ chainId: chain.id, provider: chain.aaveProvider, err: (err as Error).message }, 'aave-provider-pool-failed');
    }
  }
}
===== END liquidator/offchain/infra/aave_provider.ts =====

===== BEGIN liquidator/offchain/infra/accounts.ts =====
import type { Address } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';

import type { ChainCfg } from './config';

const executorCache = new Map<string, Address>();

export function privateKeyForChain(chain: ChainCfg): `0x${string}` | undefined {
  // Prefer the new, dynamic format
  const key = `WALLET_PK_${chain.name.toUpperCase()}`;
  const pk = process.env[key] as `0x${string}` | undefined;
  if (pk) return pk;

  // Fallback for existing aliases from the .env structure
  switch (chain.name.toLowerCase()) {
    case 'arbitrum':
      return process.env.WALLET_PK_ARB as `0x${string}` | undefined;
    case 'optimism':
    case 'op':
      return process.env.WALLET_PK_OP as `0x${string}` | undefined;
    case 'base':
      return process.env.WALLET_PK_BASE as `0x${string}` | undefined;
    case 'polygon':
      return process.env.WALLET_PK_POLYGON as `0x${string}` | undefined;
    default:
      return undefined;
  }
}

export function executorAddressForChain(chain: ChainCfg): Address | undefined {
  const pk = privateKeyForChain(chain);
  if (!pk) return undefined;

  const cached = executorCache.get(pk);
  if (cached) return cached;

  const address = privateKeyToAccount(pk).address;
  executorCache.set(pk, address);
  return address;
}

===== END liquidator/offchain/infra/accounts.ts =====

===== BEGIN liquidator/offchain/infra/attempts.ts =====
import { db } from './db';
import { log } from './logger';

const hasDb = Boolean(process.env.DATABASE_URL);
let warnedNoDb = false;

function ensureDb(action: string): boolean {
  if (hasDb) return true;
  if (!warnedNoDb) {
    log.warn({ action }, 'attempt-store-disabled');
    warnedNoDb = true;
  }
  return false;
}

const CREATE_TABLE = `
CREATE TABLE IF NOT EXISTS liquidation_attempts (
  id BIGSERIAL PRIMARY KEY,
  chain_id INTEGER NOT NULL,
  borrower TEXT NOT NULL,
  status TEXT NOT NULL,
  reason TEXT,
  tx_hash TEXT,
  details JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
)`;

const CREATE_INDEX = `
CREATE INDEX IF NOT EXISTS idx_liquidation_attempts_chain_borrower_created
  ON liquidation_attempts(chain_id, borrower, created_at DESC)`;

const ADD_DETAILS_COLUMN = `
ALTER TABLE liquidation_attempts
  ADD COLUMN IF NOT EXISTS details JSONB`;

export type AttemptStatus =
  | 'throttled'
  | 'gap_skip'
  | 'policy_skip'
  | 'dry_run'
  | 'sent'
  | 'success'
  | 'error';

export async function ensureAttemptTable(): Promise<void> {
  if (!ensureDb('init')) return;
  try {
    await db.query(CREATE_TABLE);
    await db.query(CREATE_INDEX);
    await db.query(ADD_DETAILS_COLUMN);
  } catch (err) {
    log.warn({ err: (err as Error).message }, 'attempt-table-init-failed');
  }
}

export async function recordAttemptRow(params: {
  chainId: number;
  borrower: `0x${string}`;
  status: AttemptStatus;
  reason?: string;
  txHash?: `0x${string}`;
  details?: Record<string, unknown> | null;
}): Promise<void> {
  const { chainId, borrower, status, reason, txHash, details } = params;
  if (!ensureDb('record')) return;
  try {
    await db.query(
      'INSERT INTO liquidation_attempts (chain_id, borrower, status, reason, tx_hash, details) VALUES ($1, $2, $3, $4, $5, $6)',
      [
        chainId,
        borrower.toLowerCase(),
        status,
        reason ?? null,
        txHash ?? null,
        details ? JSON.stringify(details) : null,
      ]
    );
  } catch (err) {
    log.warn({ err: (err as Error).message }, 'attempt-row-insert-failed');
  }
}

export async function recentFailureCount(params: {
  chainId: number;
  borrower: `0x${string}`;
  withinMinutes: number;
}): Promise<number> {
  if (!ensureDb('recent')) return 0;
  try {
    const res = await db.query(
      `SELECT COUNT(*)::int AS count
       FROM liquidation_attempts
       WHERE chain_id = $1 AND borrower = $2 AND status = 'error' AND created_at >= NOW() - INTERVAL '$3 minutes'`,
      [params.chainId, params.borrower.toLowerCase(), params.withinMinutes]
    );
    return res.rows[0]?.count ?? 0;
  } catch (err) {
    log.warn({ err: (err as Error).message }, 'attempt-recent-failure-query-failed');
    return 0;
  }
}

===== END liquidator/offchain/infra/attempts.ts =====

===== BEGIN liquidator/offchain/infra/throttle.ts =====
import { redis } from './redis';
import { log } from './logger';

const DEFAULT_WINDOW_SEC = 3600;

function key(chainId: number, borrower: `0x${string}`) {
  return `throttle:${chainId}:${borrower.toLowerCase()}`;
}

type FallbackEntry = { count: number; expiresAt: number };

const fallbackStore = new Map<string, FallbackEntry>();
let fallbackEnabled = false;
let fallbackWarned = false;

function enableFallback(err?: Error) {
  if (!fallbackEnabled) {
    fallbackEnabled = true;
    if (!fallbackWarned) {
      log.warn({ err: err?.message }, 'throttle-fallback-enabled');
      fallbackWarned = true;
    }
  }
}

function fallbackCount(chainId: number, borrower: `0x${string}`): number {
  const now = Date.now();
  const k = key(chainId, borrower);
  const entry = fallbackStore.get(k);
  if (!entry || entry.expiresAt <= now) {
    fallbackStore.delete(k);
    return 0;
  }
  return entry.count;
}

function fallbackIncrement(chainId: number, borrower: `0x${string}`, windowSec: number): number {
  const now = Date.now();
  const expiresAt = now + windowSec * 1000;
  const k = key(chainId, borrower);
  const entry = fallbackStore.get(k);
  if (!entry || entry.expiresAt <= now) {
    const next: FallbackEntry = { count: 1, expiresAt };
    fallbackStore.set(k, next);
    return next.count;
  }
  entry.count += 1;
  entry.expiresAt = Math.max(entry.expiresAt, expiresAt);
  fallbackStore.set(k, entry);
  return entry.count;
}

function fallbackReset(chainId: number, borrower: `0x${string}`): void {
  fallbackStore.delete(key(chainId, borrower));
}

export async function isThrottled(
  chainId: number,
  borrower: `0x${string}`,
  limit: number
): Promise<boolean> {
  if (limit <= 0) return false;
  if (fallbackEnabled || !redis) {
    return fallbackCount(chainId, borrower) >= limit;
  }
  try {
    const count = await redis.get(key(chainId, borrower));
    return count !== null && Number(count) >= limit;
  } catch (err) {
    log.warn({ err: (err as Error).message }, 'throttle-check-failed');
    enableFallback(err as Error);
    return fallbackCount(chainId, borrower) >= limit;
  }
}

export async function recordAttempt(
  chainId: number,
  borrower: `0x${string}`,
  windowSec = DEFAULT_WINDOW_SEC
): Promise<number | null> {
  if (fallbackEnabled || !redis) {
    return fallbackIncrement(chainId, borrower, windowSec);
  }
  try {
    const k = key(chainId, borrower);
    const results = await redis
      .multi()
      .incr(k)
      .expire(k, windowSec, 'NX')
      .exec();

    if (!results) return null;
    const countEntry = results[0];
    const count = countEntry?.[1];
    if (typeof count === 'number') return count;
    if (typeof count === 'string') return Number(count);
    return null;
  } catch (err) {
    log.warn({ err: (err as Error).message }, 'throttle-incr-failed');
    enableFallback(err as Error);
    return fallbackIncrement(chainId, borrower, windowSec);
  }
}

export async function resetThrottle(chainId: number, borrower: `0x${string}`): Promise<void> {
  if (fallbackEnabled || !redis) {
    fallbackReset(chainId, borrower);
    return;
  }
  try {
    await redis.del(key(chainId, borrower));
  } catch (err) {
    log.warn({ err: (err as Error).message }, 'throttle-reset-failed');
    enableFallback(err as Error);
    fallbackReset(chainId, borrower);
  }
}

===== END liquidator/offchain/infra/throttle.ts =====

===== BEGIN liquidator/offchain/infra/redis.ts =====
import Redis from 'ioredis';

const redisUrl = process.env.REDIS_URL;

export const redis = redisUrl ? new Redis(redisUrl) : null;

===== END liquidator/offchain/infra/redis.ts =====

===== BEGIN liquidator/offchain/infra/sequencer.ts =====
import { createPublicClient, http } from 'viem';

const SEQUENCER_FEED_ABI = [
  {
    name: 'latestRoundData',
    type: 'function',
    stateMutability: 'view',
    inputs: [],
    outputs: [
      { name: 'roundId', type: 'uint80' },
      { name: 'answer', type: 'int256' },
      { name: 'startedAt', type: 'uint256' },
      { name: 'updatedAt', type: 'uint256' },
      { name: 'answeredInRound', type: 'uint80' },
    ],
  },
] as const;

const clients = new Map<string, ReturnType<typeof createPublicClient>>();

export type SequencerStatus = {
  ok: boolean;
  reason?: string;
  updatedAt?: number;
};

export async function checkSequencerStatus(params: {
  rpcUrl: string;
  feed?: `0x${string}`;
  staleAfterSeconds?: number;
  recoveryGraceSeconds?: number;
}): Promise<SequencerStatus> {
  const { rpcUrl, feed, staleAfterSeconds = 120, recoveryGraceSeconds } = params;
  if (!feed) {
    return { ok: true };
  }

  let client = clients.get(rpcUrl);
  if (!client) {
    client = createPublicClient({ transport: http(rpcUrl) });
    clients.set(rpcUrl, client);
  }

  try {
    const [, answer, , updatedAt] = await client.readContract({
      address: feed,
      abi: SEQUENCER_FEED_ABI,
      functionName: 'latestRoundData',
    });

    const isUp = answer === 1n;
    if (!isUp) {
      return { ok: false, reason: 'status-down', updatedAt: Number(updatedAt) };
    }

    const updated = Number(updatedAt);
    const now = Math.floor(Date.now() / 1000);
    if (!Number.isFinite(updated) || updated === 0) {
      return { ok: false, reason: 'updated-zero' };
    }

    const age = now - updated;

    if (age > staleAfterSeconds) {
      return { ok: false, reason: `stale ${age}s`, updatedAt: updated };
    }

    const envGraceRaw = process.env.SEQUENCER_GRACE_SECS;
    const envGrace = envGraceRaw ? Number(envGraceRaw) : NaN;
    const graceSeconds = Number.isFinite(envGrace) ? envGrace : recoveryGraceSeconds ?? 120;

    if (age < graceSeconds) {
      return { ok: false, reason: `grace ${age}s`, updatedAt: updated };
    }

    return { ok: true, updatedAt: updated };
  } catch (err) {
    console.warn(`sequencer-feed-read-failed`, { err: (err as Error).message, feed, rpcUrl });
    return { ok: false, reason: 'feed-read-failed' };
  }
}

===== END liquidator/offchain/infra/sequencer.ts =====

===== BEGIN liquidator/offchain/util/deepMerge.ts =====
export type JsonRecord = Record<string, unknown>;

function isPlainObject(value: unknown): value is Record<string, unknown> {
  return typeof value === 'object' && value !== null && !Array.isArray(value);
}

function clone<T>(value: T): T {
  if (typeof structuredClone === 'function') {
    try {
      return structuredClone(value);
    } catch {
      // fall through to JSON method below
    }
  }
  return JSON.parse(JSON.stringify(value)) as T;
}

function mergeInto(target: JsonRecord, source: JsonRecord): void {
  for (const [key, value] of Object.entries(source)) {
    const current = target[key];
    if (isPlainObject(current) && isPlainObject(value)) {
      const next = { ...current };
      mergeInto(next, value);
      target[key] = next;
      continue;
    }
    target[key] = clone(value);
  }
}

export function deepMerge<T extends JsonRecord>(base: T, patch: JsonRecord): T {
  const result = clone(base);
  mergeInto(result, patch);
  return result as T;
}

===== END liquidator/offchain/util/deepMerge.ts =====

===== BEGIN liquidator/offchain/util/routes.ts =====
import type { Address } from 'viem';
import { AppConfig, ChainCfg } from '../infra/config';
import { RouteOption } from '../simulator/router';

const DEFAULT_UNI_FEES = [100, 500, 3000, 10000];

type RouteBuildResult = {
  options: RouteOption[];
  gapFee: number;
  gapRouter?: Address;
};

export function buildRouteOptions(
  cfg: AppConfig,
  chain: ChainCfg,
  debtSymbol: string,
  collateralSymbol: string
): RouteBuildResult {
  const options: RouteOption[] = [];
  const chainDex = cfg.dexRouters?.[chain.id];
  const debtToken = chain.tokens[debtSymbol];
  const collateralToken = chain.tokens[collateralSymbol];

  if (!chainDex) {
    // Fallback to default UniV3 if no dexRouters are configured for the chain
    const uniRouter = chain.uniV3Router as Address | undefined;
    if (uniRouter) {
      for (const fee of DEFAULT_UNI_FEES) {
        options.push({ type: 'UniV3', router: uniRouter, fee });
      }
    }
    return { options, gapFee: DEFAULT_UNI_FEES[1], gapRouter: uniRouter };
  }

  // Uniswap V3
  const uniV3Router = (chainDex.uniV3 ?? chain.uniV3Router) as Address | undefined;
  if (uniV3Router) {
    for (const fee of DEFAULT_UNI_FEES) {
      options.push({ type: 'UniV3', router: uniV3Router, fee });
    }
  }

  const stableSymbols = new Set(['USDC', 'USDT', 'DAI', 'LUSD', 'SUSD', 'USDC.E', 'USDBC']);
  const stableToken = chain.tokens.USDC || chain.tokens.USDbC || chain.tokens['USDC.e'];
  const stableSymbol = stableToken
    ? Object.entries(chain.tokens).find(([, info]) => info.address.toLowerCase() === stableToken.address.toLowerCase())?.[0] ?? 'USDC'
    : 'USDC';
  const wethToken = chain.tokens.WETH ?? chain.tokens.ETH;
  const wethSymbol = wethToken
    ? Object.entries(chain.tokens).find(([, info]) => info.address.toLowerCase() === wethToken.address.toLowerCase())?.[0] ?? 'WETH'
    : 'WETH';

  const multiHopCandidates: Array<{ path: Address[]; fees: number[] }> = [];
  const pickFee = (a: string, b: string) => (stableSymbols.has(a.toUpperCase()) && stableSymbols.has(b.toUpperCase()) ? 100 : 500);

  if (uniV3Router && debtToken && collateralToken) {
    if (stableToken && stableToken.address !== debtToken.address && stableToken.address !== collateralToken.address) {
      multiHopCandidates.push({
        path: [collateralToken.address as Address, stableToken.address as Address, debtToken.address as Address],
        fees: [pickFee(collateralSymbol, stableSymbol), pickFee(stableSymbol, debtSymbol)],
      });
    }
    if (wethToken && wethToken.address !== debtToken.address && wethToken.address !== collateralToken.address) {
      multiHopCandidates.push({
        path: [collateralToken.address as Address, wethToken.address as Address, debtToken.address as Address],
        fees: [pickFee(collateralSymbol, wethSymbol), pickFee(wethSymbol, debtSymbol)],
      });
    }
    for (const candidate of multiHopCandidates) {
      if (new Set(candidate.path.map((addr) => addr.toLowerCase())).size !== candidate.path.length) continue;
      options.push({ type: 'UniV3Multi', router: uniV3Router, path: candidate.path, fees: candidate.fees });
    }
  }

  // Camelot (Uniswap V2 fork)
  if (chainDex.camelotV2) {
    options.push({ type: 'UniV2', router: chainDex.camelotV2 as Address });
  }

  // Velodrome (Solidly V2 fork)
  if (chainDex.velodrome && chainDex.velodromeFactory) {
    options.push({
      type: 'SolidlyV2',
      router: chainDex.velodrome as Address,
      factory: chainDex.velodromeFactory as Address,
      stable: true,
    });
    options.push({
      type: 'SolidlyV2',
      router: chainDex.velodrome as Address,
      factory: chainDex.velodromeFactory as Address,
      stable: false,
    });
  }

  // Aerodrome (Solidly V2 fork)
  if (chainDex.aerodrome && chainDex.aerodromeFactory) {
    options.push({
      type: 'SolidlyV2',
      router: chainDex.aerodrome as Address,
      factory: chainDex.aerodromeFactory as Address,
      stable: true,
    });
    options.push({
      type: 'SolidlyV2',
      router: chainDex.aerodrome as Address,
      factory: chainDex.aerodromeFactory as Address,
      stable: false,
    });
  }
  
  // Determine a sensible default for price gap checking
  const gapRouter = uniV3Router ?? (chainDex.camelotV2 as Address) ?? (chainDex.velodrome as Address);
  const gapFee = DEFAULT_UNI_FEES[1]; // 500 bps is a common default

  return { options, gapFee, gapRouter };
}

===== END liquidator/offchain/util/routes.ts =====

===== BEGIN liquidator/offchain/util/serialize.ts =====
import type { Candidate } from '../indexer/aave_indexer';
import type { TokenInfo } from '../infra/config';
import type { Plan as SimPlan } from '../simulator/simulate';
import type { RouteOption } from '../simulator/router';

export type RouteSnapshot = {
  type: RouteOption['type'];
  router: string;
  fee?: number;
  stable?: boolean;
  path?: string;
};

export type CandidateSnapshot = {
  borrower: `0x${string}`;
  chainId: number;
  debt: {
    symbol: string;
    address: `0x${string}`;
    decimals: number;
    amount: string;
  };
  collateral: {
    symbol: string;
    address: `0x${string}`;
    decimals: number;
    amount: string;
  };
  healthFactor: number;
  debtPriceUsd?: number;
  collateralPriceUsd?: number;
  gapBps?: number;
  routeCandidates?: RouteSnapshot[];
  timestamp: number;
};

export type PlanSnapshot = {
  repayAmount: string;
  seizeAmount: string;
  dexId: number;
  router: string;
  uniFee?: number;
  solidlyStable?: boolean;
  solidlyFactory?: string;
  amountOutMin: string;
  estNetBps: number;
  gasUsd?: number;
  path?: string;
  executionMode?: string;
  precommit?: boolean;
};

export function serializeRoutes(options: RouteOption[]): RouteSnapshot[] {
  return options.map((option) => {
    switch (option.type) {
      case 'UniV3':
        return { type: option.type, router: option.router, fee: option.fee };
      case 'SolidlyV2':
        return {
          type: option.type,
          router: option.router,
          fee: option.stable ? 0 : undefined,
          stable: option.stable,
        };
      case 'UniV3Multi':
        return {
          type: option.type,
          router: option.router,
          path: option.path.join('->'),
          fee: option.fees?.[0],
        };
      default:
        return { type: option.type, router: option.router };
    }
  });
}

export function serializeCandidate(input: {
  candidate: Candidate;
  debtToken: TokenInfo;
  collateralToken: TokenInfo;
  debtPriceUsd?: number;
  collateralPriceUsd?: number;
  gapBps?: number;
  routeOptions?: RouteOption[];
}): CandidateSnapshot {
  const { candidate, debtToken, collateralToken, debtPriceUsd, collateralPriceUsd, gapBps, routeOptions } = input;
  return {
    borrower: candidate.borrower,
    chainId: candidate.chainId,
    debt: {
      symbol: candidate.debt.symbol,
      address: candidate.debt.address,
      decimals: debtToken.decimals,
      amount: candidate.debt.amount.toString(),
    },
    collateral: {
      symbol: candidate.collateral.symbol,
      address: candidate.collateral.address,
      decimals: collateralToken.decimals,
      amount: candidate.collateral.amount.toString(),
    },
    healthFactor: (candidate as Candidate).healthFactor,
    debtPriceUsd,
    collateralPriceUsd,
    gapBps,
    routeCandidates: routeOptions ? serializeRoutes(routeOptions) : undefined,
    timestamp: Date.now(),
  };
}

export function serializePlan(plan: SimPlan): PlanSnapshot {
  return {
    repayAmount: plan.repayAmount.toString(),
    seizeAmount: plan.seizeAmount.toString(),
    dexId: plan.dexId,
    router: plan.router,
    uniFee: plan.uniFee,
    solidlyStable: plan.solidlyStable,
    solidlyFactory: plan.solidlyFactory,
    amountOutMin: plan.amountOutMin.toString(),
    estNetBps: plan.estNetBps,
    gasUsd: plan.gasUsd,
    path: plan.path,
    executionMode: plan.mode,
    precommit: plan.precommit,
  };
}

export function serializeError(err: unknown): string {
  if (err instanceof Error) return err.message;
  return typeof err === 'string' ? err : JSON.stringify(err);
}

===== END liquidator/offchain/util/serialize.ts =====

===== BEGIN liquidator/offchain/tools/aave_feeds.ts =====
import '../infra/env';
import { createPublicClient, getAddress, http } from 'viem';
import { loadConfig } from '../infra/config';

const PROVIDER_ABI = [
  {
    type: 'function',
    name: 'getPriceOracle',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ type: 'address' }],
  },
] as const;

const ORACLE_ABI = [
  {
    type: 'function',
    name: 'getSourceOfAsset',
    stateMutability: 'view',
    inputs: [{ name: 'asset', type: 'address' }],
    outputs: [{ type: 'address' }],
  },
] as const;

async function main() {
  const cfg = loadConfig();
  for (const chain of cfg.chains.filter((c) => c.enabled)) {
    const client = createPublicClient({ transport: http(chain.rpc) });
    if (!chain.aaveProvider) {
      console.log(`Chain ${chain.id} missing aaveProvider`);
      continue;
    }
    try {
      const oracle = await client.readContract({
        address: getAddress(chain.aaveProvider),
        abi: PROVIDER_ABI,
        functionName: 'getPriceOracle',
      });
      console.log(`\nChain ${chain.id} (${chain.name}) oracle: ${oracle}`);
      for (const [symbol, token] of Object.entries(chain.tokens)) {
        try {
          const source = await client.readContract({
            address: getAddress(oracle as string),
            abi: ORACLE_ABI,
            functionName: 'getSourceOfAsset',
            args: [getAddress(token.address)],
          });
          console.log(`  ${symbol}: ${source}`);
        } catch (err) {
          console.log(`  ${symbol}: failed (${(err as Error).message})`);
        }
      }
    } catch (err) {
      console.log(`Failed to load oracle for chain ${chain.id}: ${(err as Error).message}`);
    }
  }
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
===== END liquidator/offchain/tools/aave_feeds.ts =====

===== BEGIN liquidator/offchain/tools/aave_sources.ts =====
import '../infra/env';
import { createPublicClient, getAddress, http } from 'viem';
import { loadConfig } from '../infra/config';
import { getPoolFromProvider } from '../infra/aave_provider';

const POOL_ABI = [
  { type: 'function', name: 'getReservesList', stateMutability: 'view', inputs: [], outputs: [{ type: 'address[]' }] },
] as const;

const ERC20_ABI = [
  { type: 'function', name: 'symbol', stateMutability: 'view', inputs: [], outputs: [{ type: 'string' }] },
  { type: 'function', name: 'decimals', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint8' }] },
] as const;

const PROVIDER_ABI = [
  { type: 'function', name: 'getPriceOracle', stateMutability: 'view', inputs: [], outputs: [{ type: 'address' }] },
] as const;

const ORACLE_ABI = [
  { type: 'function', name: 'getSourceOfAsset', stateMutability: 'view', inputs: [{ type: 'address' }], outputs: [{ type: 'address' }] },
] as const;

async function main() {
  const cfg = loadConfig();
  for (const chain of cfg.chains.filter((c) => c.enabled)) {
    const pool = await getPoolFromProvider(chain.rpc, chain.aaveProvider);
    const client = createPublicClient({ transport: http(chain.rpc) });
    const registry = await client.readContract({ address: getAddress(chain.aaveProvider), abi: PROVIDER_ABI, functionName: 'getPriceOracle' });
    console.log(`\nChain ${chain.id} oracle ${registry}`);
    const reserves = await client.readContract({ address: pool, abi: POOL_ABI, functionName: 'getReservesList' }) as `0x${string}`[];
    for (const asset of reserves) {
      try {
        const [symbol, decimals, source] = await Promise.all([
          client.readContract({ address: asset, abi: ERC20_ABI, functionName: 'symbol' }) as Promise<string>,
          client.readContract({ address: asset, abi: ERC20_ABI, functionName: 'decimals' }) as Promise<number>,
          client.readContract({ address: registry as `0x${string}`, abi: ORACLE_ABI, functionName: 'getSourceOfAsset', args: [asset] }) as Promise<string>,
        ]);
        console.log(`  ${symbol.padEnd(7)} ${asset} decimals=${decimals} feed=${source}`);
      } catch (err) {
        console.log(`  ${asset} failed: ${(err as Error).message}`);
      }
    }
  }
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
===== END liquidator/offchain/tools/aave_sources.ts =====

===== BEGIN liquidator/offchain/tools/dump_candidates.ts =====
import '../infra/env';
import { loadConfig } from '../infra/config';
import { streamCandidates } from '../indexer/aave_indexer';

async function main() {
  const cfg = loadConfig();
  const counts = new Map<string, number>();
  const byChain = new Map<number, number>();
  const sample: Record<string, Set<string>> = {};

  let total = 0;
  for await (const candidate of streamCandidates(cfg)) {
    total += 1;
    const key = `${candidate.chainId}:${candidate.debt.symbol}`;
    counts.set(key, (counts.get(key) ?? 0) + 1);
    byChain.set(candidate.chainId, (byChain.get(candidate.chainId) ?? 0) + 1);
    const chainKey = `${candidate.chainId}`;
    if (!sample[chainKey]) sample[chainKey] = new Set();
    if (sample[chainKey].size < 10) {
      sample[chainKey].add(`${candidate.debt.symbol}->${candidate.collateral.symbol}`);
    }
    if (total >= 500) break;
  }

  console.log('total candidates sampled:', total);
  console.log('by chain:', Array.from(byChain.entries()));
  console.log('top debt symbols:');
  for (const [key, count] of Array.from(counts.entries()).sort((a, b) => b[1] - a[1]).slice(0, 20)) {
    console.log(`  ${key}: ${count}`);
  }
  console.log('sample combos per chain:');
  for (const [chain, combos] of Object.entries(sample)) {
    console.log(`  chain ${chain}: ${Array.from(combos).join(', ')}`);
  }
  process.exit(0);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
===== END liquidator/offchain/tools/dump_candidates.ts =====

===== BEGIN liquidator/offchain/tools/feed-check.ts =====
import '../infra/env';
import { createPublicClient, http } from 'viem';
import { loadConfig, ChainCfg } from '../infra/config';
import { log } from '../infra/logger';

// Minimal Chainlink aggregator ABI
const AGGREGATOR_ABI = [
  { inputs: [], name: 'latestRoundData', outputs: [
      { name: 'roundId', type: 'uint80' },
      { name: 'answer', type: 'int256' },
      { name: 'startedAt', type: 'uint256' },
      { name: 'updatedAt', type: 'uint256' },
      { name: 'answeredInRound', type: 'uint80' },
    ], stateMutability: 'view', type: 'function' },
  { inputs: [], name: 'decimals', outputs: [{ name: '', type: 'uint8' }], stateMutability: 'view', type: 'function' },
];

async function checkChainFeeds(chain: ChainCfg) {
  const client = createPublicClient({ transport: http(chain.rpc) });
  for (const [sym, t] of Object.entries(chain.tokens)) {
    if (!t.chainlinkFeed) {
      log.warn({ chain: chain.id, sym }, 'no-feed');
      continue;
    }
    try {
      const [dec, round] = await Promise.all([
        client.readContract({ address: t.chainlinkFeed, abi: AGGREGATOR_ABI as any, functionName: 'decimals', args: [] }),
        client.readContract({ address: t.chainlinkFeed, abi: AGGREGATOR_ABI as any, functionName: 'latestRoundData', args: [] }),
      ]);
      const decimals = Number(dec);
      const answer = BigInt((round as any).answer ?? (round as any)[1]);
      const updatedAt = BigInt((round as any).updatedAt ?? (round as any)[3]);
      log.info({ chain: chain.id, sym, feed: t.chainlinkFeed, price: answer.toString(), decimals, updatedAt: updatedAt.toString() }, 'feed');
    } catch (err) {
      log.error({ chain: chain.id, sym, feed: t.chainlinkFeed, err: (err as Error).message }, 'feed-error');
    }
  }
}

async function main() {
  const cfg = loadConfig();
  for (const chain of cfg.chains.filter((c) => c.enabled)) {
    await checkChainFeeds(chain);
  }
}

main().catch((e) => { console.error(e); process.exit(1); });

===== END liquidator/offchain/tools/feed-check.ts =====

===== BEGIN liquidator/offchain/tools/fetch_feeds.ts =====
import '../infra/env';
import { createPublicClient, getAddress, http } from 'viem';
import { loadConfig } from '../infra/config';

const FEED_REGISTRY = '0x47Fb2585D2C56Fe188D0E6ec628a38B74fCeeeDf';
const USD_ADDRESS = '0x0000000000000000000000000000000000000348';

const FEED_REGISTRY_ABI = [
  {
    type: 'function',
    name: 'getFeed',
    stateMutability: 'view',
    inputs: [
      { name: 'base', type: 'address' },
      { name: 'quote', type: 'address' },
    ],
    outputs: [{ name: 'aggregator', type: 'address' }],
  },
] as const;

async function main() {
  const cfg = loadConfig();
  for (const chain of cfg.chains.filter((c) => c.enabled)) {
    const client = createPublicClient({ transport: http(chain.rpc) });
    console.log(`\nChain ${chain.id} (${chain.name})`);
    for (const [symbol, token] of Object.entries(chain.tokens)) {
      if (token.chainlinkFeed) {
        console.log(`${symbol}: already set -> ${token.chainlinkFeed}`);
        continue;
      }
      try {
        const aggregator = await client.readContract({
          address: getAddress(FEED_REGISTRY),
          abi: FEED_REGISTRY_ABI,
          functionName: 'getFeed',
          args: [getAddress(token.address), getAddress(USD_ADDRESS)],
        });
        // TODO: write discovered feeds back into config.yaml once validated against production routes.
        console.log(`${symbol}: ${aggregator}`);
      } catch (err) {
        console.log(`${symbol}: feed lookup failed (${(err as Error).message})`);
      }
    }
  }
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});

===== END liquidator/offchain/tools/fetch_feeds.ts =====

===== BEGIN liquidator/offchain/tools/list_reserves.ts =====
import '../infra/env';
import { createPublicClient, http } from 'viem';
import { loadConfig } from '../infra/config';
import { getPoolFromProvider } from '../infra/aave_provider';

const ERC20_ABI = [
  { type: 'function', name: 'symbol', stateMutability: 'view', inputs: [], outputs: [{ type: 'string' }] },
  { type: 'function', name: 'decimals', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint8' }] },
] as const;

const POOL_ABI = [
  { type: 'function', name: 'getReservesList', stateMutability: 'view', inputs: [], outputs: [{ type: 'address[]' }] },
] as const;

async function main() {
  const cfg = loadConfig();
  for (const chain of cfg.chains.filter((c) => c.enabled)) {
    const poolAddr = await getPoolFromProvider(chain.rpc, chain.aaveProvider);
    const client = createPublicClient({ transport: http(chain.rpc) });
    const reserves = await client.readContract({ address: poolAddr, abi: POOL_ABI, functionName: 'getReservesList' }) as `0x${string}`[];
    console.log(`\nChain ${chain.id} (${chain.name}) pool ${poolAddr}`);
    for (const asset of reserves) {
      try {
        const symbol = await client.readContract({ address: asset, abi: ERC20_ABI, functionName: 'symbol' });
        const decimals = await client.readContract({ address: asset, abi: ERC20_ABI, functionName: 'decimals' });
        console.log(`  ${asset} -> ${symbol} (${decimals})`);
      } catch (err) {
        console.log(`  ${asset} -> failed (${(err as Error).message})`);
      }
    }
  }
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
===== END liquidator/offchain/tools/list_reserves.ts =====

===== BEGIN liquidator/offchain/tools/preflight.ts =====
import '../infra/env';
import { Address, createPublicClient, formatEther, formatUnits, getAddress, http, parseEther } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { loadConfig, ChainCfg, TokenInfo, AppConfig } from '../infra/config';
import { log } from '../infra/logger';
import { db } from '../infra/db';
import { redis } from '../infra/redis';
import { oraclePriceDetails } from '../indexer/price_watcher';

const QUOTER_V2_ABI = [
  {
    name: 'quoteExactInputSingle',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [
      {
        name: 'params',
        type: 'tuple',
        components: [
          { name: 'tokenIn', type: 'address' },
          { name: 'tokenOut', type: 'address' },
          { name: 'amountIn', type: 'uint256' },
          { name: 'fee', type: 'uint24' },
          { name: 'sqrtPriceLimitX96', type: 'uint160' },
        ],
      },
    ],
    outputs: [
      { name: 'amountOut', type: 'uint256' },
      { name: 'sqrtPriceX96After', type: 'uint160' },
      { name: 'initializedTicksCrossed', type: 'uint32' },
      { name: 'gasEstimate', type: 'uint256' },
    ],
  },
] as const;

const UNIV2_ROUTER_ABI = [
  {
    type: 'function',
    name: 'getAmountsOut',
    stateMutability: 'view',
    inputs: [
      { name: 'amountIn', type: 'uint256' },
      { name: 'path', type: 'address[]' },
    ],
    outputs: [{ name: 'amounts', type: 'uint256[]' }],
  },
] as const;

const SOLIDLY_ROUTER_ABI = [
  {
    type: 'function',
    name: 'getAmountsOut',
    stateMutability: 'view',
    inputs: [
      { name: 'amountIn', type: 'uint256' },
      {
        name: 'routes',
        type: 'tuple[]',
        components: [
          { name: 'from', type: 'address' },
          { name: 'to', type: 'address' },
          { name: 'stable', type: 'bool' },
          { name: 'factory', type: 'address' },
        ],
      },
    ],
    outputs: [{ name: 'amounts', type: 'uint256[]' }],
  },
] as const;

const ERC20_ABI = [
  {
    type: 'function',
    name: 'balanceOf',
    stateMutability: 'view',
    inputs: [{ name: 'account', type: 'address' }],
    outputs: [{ name: 'amount', type: 'uint256' }],
  },
] as const;

const LIQUIDATOR_STATE_ABI = [
  {
    type: 'function',
    name: 'owner',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ type: 'address' }],
  },
  {
    type: 'function',
    name: 'paused',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ type: 'bool' }],
  },
  {
    type: 'function',
    name: 'beneficiary',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ type: 'address' }],
  },
  {
    type: 'function',
    name: 'allowedRouters',
    stateMutability: 'view',
    inputs: [{ type: 'address', name: 'router' }],
    outputs: [{ type: 'bool' }],
  },
] as const;

const ENV_KEYS: Record<number, string> = {
  42161: 'AAVE_V3_SUBGRAPH_ARB',
  10: 'AAVE_V3_SUBGRAPH_OP',
  8453: 'AAVE_V3_SUBGRAPH_BASE',
  137: 'AAVE_V3_SUBGRAPH_POLYGON',
};

const SUBGRAPH_IDS: Record<number, string> = {
  42161: 'DLuE98kEb5pQNXAcKFQGQgfSQ57Xdou4jnVbAEqMfy3B',
  10: 'DSfLz8oQBUeU5atALgUFQKMTSYV9mZAVYp4noLSXAfvb',
  8453: 'GQFbb95cE6d8mV989mL5figjaGaKCQB3xqYrr1bRyXqF',
  137: 'Co2URyXjnxaw8WqxKyVHdirq9Ahhm5vcTs4dMedAq211',
};

const FALLBACKS: Record<number, string> = {
  42161: 'https://api.thegraph.com/subgraphs/name/aave/protocol-v3-arbitrum',
  10: 'https://api.thegraph.com/subgraphs/name/aave/protocol-v3-optimism',
  8453: '',
  137: '',
};

const WALLET_PK_ENV: Record<number, string> = {
  42161: 'WALLET_PK_ARB',
  10: 'WALLET_PK_OP',
  8453: 'WALLET_PK_BASE',
  137: 'WALLET_PK_POLYGON',
};

const SAFE_ADDRESS_ENV: Record<number, string> = {
  42161: 'SAFE_ADDRESS_ARB',
  10: 'SAFE_ADDRESS_OP',
  8453: 'SAFE_ADDRESS_BASE',
  137: 'SAFE_ADDRESS_POLYGON',
};

const MIN_NATIVE_BALANCE_ENV: Record<number, string> = {
  42161: 'MIN_NATIVE_BALANCE_ARB',
  10: 'MIN_NATIVE_BALANCE_OP',
  8453: 'MIN_NATIVE_BALANCE_BASE',
  137: 'MIN_NATIVE_BALANCE_POLYGON',
};

const DEFAULT_MIN_NATIVE_BALANCE = '0.05';

const PING_QUERY = `
  query SubgraphMeta {
    _meta {
      block {
        number
        timestamp
      }
      deployment
    }
  }
`;

function endpointFor(chainId: number): string {
  const key = ENV_KEYS[chainId];
  if (!key) return '';
  const envValue = process.env[key];
  if (envValue && !envValue.includes('<') && !envValue.includes('MISSING')) {
    return envValue;
  }
  const apiKey = process.env.GRAPH_API_KEY?.trim();
  const subgraphId = SUBGRAPH_IDS[chainId];
  if (apiKey && subgraphId) {
    return `https://gateway.thegraph.com/api/${apiKey}/subgraphs/id/${subgraphId}`;
  }
  return FALLBACKS[chainId] ?? '';
}

async function checkDatabase(): Promise<boolean> {
  if (!process.env.DATABASE_URL) {
    log.warn({ env: 'DATABASE_URL' }, 'preflight-db-missing-env');
    return false;
  }
  try {
    await db.query('SELECT 1');
    log.info({}, 'preflight-db-ok');
    return true;
  } catch (err) {
    log.error({ err: (err as Error).message }, 'preflight-db-failed');
    return false;
  }
}

async function checkRedis(): Promise<boolean> {
  if (!process.env.REDIS_URL) {
    log.warn({ env: 'REDIS_URL' }, 'preflight-redis-missing-env');
    return false;
  }
  if (!redis) {
    log.error({}, 'preflight-redis-uninitialized');
    return false;
  }
  try {
    await redis.ping();
    log.info({}, 'preflight-redis-ok');
    return true;
  } catch (err) {
    log.error({ err: (err as Error).message }, 'preflight-redis-failed');
    return false;
  }
}

async function checkRpcs(cfg = loadConfig()): Promise<boolean> {
  let ok = true;
  for (const chain of cfg.chains.filter((c) => c.enabled)) {
    try {
      const client = createPublicClient({ transport: http(chain.rpc) });
      const block = await client.getBlockNumber();
      log.info({ chainId: chain.id, block: block.toString() }, 'preflight-rpc-ok');
    } catch (err) {
      ok = false;
      log.error({ chainId: chain.id, err: (err as Error).message }, 'preflight-rpc-failed');
    }
  }
  return ok;
}

async function pingSubgraph(chainId: number, url: string) {
  if (!url) {
    log.warn({ chainId }, 'preflight-subgraph-missing-url');
    return false;
  }
  const started = Date.now();
  try {
    const headers: Record<string, string> = { 'content-type': 'application/json' };
    const apiKey = process.env.GRAPH_API_KEY?.trim();
    if (apiKey) headers.authorization = `Bearer ${apiKey}`;
    const res = await fetch(url, {
      method: 'POST',
      headers,
      body: JSON.stringify({ query: PING_QUERY }),
    });
    const elapsed = Date.now() - started;
    if (!res.ok) {
      const text = await res.text();
      log.error({ chainId, url, status: res.status, text, elapsed }, 'preflight-subgraph-http-failed');
      return false;
    }
    const json = (await res.json()) as { data?: { _meta?: { block?: { number?: number; timestamp?: number }; deployment?: string } }; errors?: unknown };
    if (json.errors) {
      log.error({ chainId, url, errors: json.errors, elapsed }, 'preflight-subgraph-graphql-failed');
      return false;
    }
    const meta = json.data?._meta ?? {};
    log.info({ chainId, url, block: meta.block?.number, timestamp: meta.block?.timestamp, deployment: meta.deployment, elapsed }, 'preflight-subgraph-ok');
    return true;
  } catch (err) {
    log.error({ chainId, url, err: (err as Error).message }, 'preflight-subgraph-request-failed');
    return false;
  }
}

async function checkSubgraphs(cfg = loadConfig()): Promise<boolean> {
  const seen = new Set<number>();
  for (const market of cfg.markets.filter((m) => m.enabled)) {
    seen.add(market.chainId);
  }
  let ok = true;
  for (const chainId of seen) {
    const url = endpointFor(chainId);
    const result = await pingSubgraph(chainId, url);
    ok = ok && result;
  }
  return ok;
}

async function checkQuotes(cfg = loadConfig()): Promise<boolean> {
  let ok = true;
  for (const chain of cfg.chains.filter((c) => c.enabled)) {
    const client = createPublicClient({ transport: http(chain.rpc) });
    const tokens = chain.tokens;
    const usdc = tokens['USDC'] || tokens['USDC.e'] || tokens['USDbC'];
    const weth = tokens['WETH'] || tokens['ETH'];
    if (!usdc || !weth) {
      log.warn({ chainId: chain.id }, 'preflight-quote-missing-tokens');
      ok = false;
      continue;
    }

    const amountIn = BigInt(1_000_000);
    const usdcAddr = getAddress(usdc.address as Address);
    const wethAddr = getAddress(weth.address as Address);

  const fees = [100, 500, 3000];
    for (const fee of fees) {
      try {
        if (!chain.quoter) {
          log.warn({ chainId: chain.id }, 'preflight-quote-missing-quoter');
          ok = false;
          continue;
        }
        const quoter = getAddress(chain.quoter as Address);
        const { result } = await client.simulateContract({
          address: quoter,
          abi: QUOTER_V2_ABI,
          functionName: 'quoteExactInputSingle',
          args: [{ tokenIn: usdcAddr, tokenOut: wethAddr, amountIn, fee, sqrtPriceLimitX96: 0n }],
          account: usdcAddr,
        });
        const amountOut = (result as any)[0] as bigint;
        log.info({ chainId: chain.id, dex: 'UniV3', fee, amountIn: amountIn.toString(), amountOut: amountOut.toString() }, 'preflight-quote-ok');
      } catch (err) {
        ok = false;
        log.error({ chainId: chain.id, dex: 'UniV3', fee, err: (err as Error).message }, 'preflight-quote-failed');
      }
    }

  const dex = cfg.dexRouters?.[chain.id] ?? {};
    if (dex.camelotV2) {
      try {
        const amounts = await client.readContract({
          address: getAddress(dex.camelotV2 as Address),
          abi: UNIV2_ROUTER_ABI,
          functionName: 'getAmountsOut',
          args: [amountIn, [usdcAddr, wethAddr]],
        });
        const out = (amounts as any).amounts ?? amounts;
        const last = Array.isArray(out) ? out[out.length - 1] : out;
        log.info({ chainId: chain.id, dex: 'CamelotV2', amountOut: (last as bigint).toString() }, 'preflight-quote-ok');
      } catch (err) {
        ok = false;
        log.error({ chainId: chain.id, dex: 'CamelotV2', err: (err as Error).message }, 'preflight-quote-failed');
      }
    }

    if (dex.velodrome && dex.velodromeFactory) {
      try {
        const amounts = await client.readContract({
          address: getAddress(dex.velodrome as Address),
          abi: SOLIDLY_ROUTER_ABI,
          functionName: 'getAmountsOut',
          args: [amountIn, [{ from: usdcAddr, to: wethAddr, stable: false, factory: getAddress(dex.velodromeFactory as Address) }]],
        });
        const out = (amounts as any).amounts ?? amounts;
        const last = Array.isArray(out) ? out[out.length - 1] : out;
        log.info({ chainId: chain.id, dex: 'Velodrome', amountOut: (last as bigint).toString() }, 'preflight-quote-ok');
      } catch (err) {
        ok = false;
        log.error({ chainId: chain.id, dex: 'Velodrome', err: (err as Error).message }, 'preflight-quote-failed');
      }
    }

    if (dex.aerodrome && dex.aerodromeFactory) {
      try {
        const amounts = await client.readContract({
          address: getAddress(dex.aerodrome as Address),
          abi: SOLIDLY_ROUTER_ABI,
          functionName: 'getAmountsOut',
          args: [amountIn, [{ from: usdcAddr, to: wethAddr, stable: false, factory: getAddress(dex.aerodromeFactory as Address) }]],
        });
        const out = (amounts as any).amounts ?? amounts;
        const last = Array.isArray(out) ? out[out.length - 1] : out;
        log.info({ chainId: chain.id, dex: 'Aerodrome', amountOut: (last as bigint).toString() }, 'preflight-quote-ok');
      } catch (err) {
        ok = false;
        log.error({ chainId: chain.id, dex: 'Aerodrome', err: (err as Error).message }, 'preflight-quote-failed');
      }
    }
  }
  return ok;
}

async function checkOracles(cfg = loadConfig()): Promise<boolean> {
  let ok = true;
  for (const chain of cfg.chains.filter((c) => c.enabled)) {
    const client = createPublicClient({ transport: http(chain.rpc) });
    for (const [symbol, token] of Object.entries(chain.tokens)) {
      if (!token.chainlinkFeed) continue;
      try {
        const detail = await oraclePriceDetails(client, token);
        if (!detail || typeof detail.priceUsd !== 'number') {
          log.warn({ chainId: chain.id, symbol, token: token.address }, 'preflight-oracle-missing-price');
          continue;
        }

        if (detail.stale) {
          log.warn({ chainId: chain.id, symbol, price: detail.priceUsd, ageSec: detail.ageSeconds }, 'preflight-oracle-stale');
        } else {
          log.info({ chainId: chain.id, symbol, price: detail.priceUsd, ageSec: detail.ageSeconds }, 'preflight-oracle-ok');
        }
      } catch (err) {
        ok = false;
        log.error({ chainId: chain.id, symbol, err: (err as Error).message }, 'preflight-oracle-failed');
      }
    }
  }
  return ok;
}

function minNativeBalanceWei(chainId: number): bigint {
  const specific = process.env[MIN_NATIVE_BALANCE_ENV[chainId] ?? ''] ?? process.env.MIN_NATIVE_BALANCE_DEFAULT;
  const raw = (specific && specific.trim().length > 0 ? specific : DEFAULT_MIN_NATIVE_BALANCE).trim();
  try {
    return parseEther(raw);
  } catch {
    log.warn({ chainId, raw }, 'preflight-native-balance-threshold-invalid');
    return parseEther(DEFAULT_MIN_NATIVE_BALANCE);
  }
}

async function checkWalletBalances(cfg = loadConfig()): Promise<boolean> {
  let ok = true;
  for (const chain of cfg.chains.filter((c) => c.enabled)) {
    const pkEnv = WALLET_PK_ENV[chain.id];
    if (!pkEnv) {
      log.warn({ chainId: chain.id }, 'preflight-wallet-missing-env-mapping');
      ok = false;
      continue;
    }
    const pk = process.env[pkEnv];
    if (!pk || pk.includes('MISSING')) {
      log.warn({ chainId: chain.id, env: pkEnv }, 'preflight-wallet-missing');
      ok = false;
      continue;
    }
    let account;
    try {
      account = privateKeyToAccount(pk as `0x${string}`);
    } catch (err) {
      log.error({ chainId: chain.id, env: pkEnv, err: (err as Error).message }, 'preflight-wallet-invalid');
      ok = false;
      continue;
    }
    const client = createPublicClient({ transport: http(chain.rpc) });
    try {
      const balance = await client.getBalance({ address: account.address });
      const minBalance = minNativeBalanceWei(chain.id);
      const balanceEth = formatEther(balance);
      const minEth = formatEther(minBalance);
      if (balance < minBalance) {
        log.warn({ chainId: chain.id, address: account.address, balanceEth, minEth }, 'preflight-wallet-low-balance');
        ok = false;
      } else {
        log.info({ chainId: chain.id, address: account.address, balanceEth }, 'preflight-wallet-ok');
      }
    } catch (err) {
      ok = false;
      log.error({ chainId: chain.id, err: (err as Error).message }, 'preflight-wallet-balance-failed');
    }
  }
  return ok;
}

function routersForChain(chain: ChainCfg, cfg: AppConfig): `0x${string}`[] {
  const routers = new Set<string>();
  if (chain.uniV3Router) routers.add(getAddress(chain.uniV3Router as Address));
  const extra = cfg.dexRouters?.[chain.id];
  if (extra) {
    for (const [key, value] of Object.entries(extra)) {
      if (typeof value !== 'string' || !value.startsWith('0x') || value.length !== 42) continue;
      const keyLower = key.toLowerCase();
      if (keyLower.includes('factory') || keyLower === 'tokens') continue;
      routers.add(getAddress(value as Address));
    }
  }
  return Array.from(routers) as `0x${string}`[];
}

function tokensForChain(cfg: AppConfig, chainId: number): { symbol: string; info: TokenInfo }[] {
  const chain = cfg.chains.find((c) => c.id === chainId);
  if (!chain) return [];
  const markets = cfg.markets.filter((m) => m.enabled && m.chainId === chainId);
  const seen = new Set<string>();
  const out: { symbol: string; info: TokenInfo }[] = [];
  for (const market of markets) {
    for (const asset of [market.debtAsset, market.collateralAsset]) {
      const info = chain.tokens[asset];
      if (!info) {
        log.warn({ chainId, asset }, 'preflight-token-missing-config');
        continue;
      }
      const key = info.address.toLowerCase();
      if (seen.has(key)) continue;
      seen.add(key);
      out.push({ symbol: asset, info });
    }
  }
  return out;
}

async function checkContracts(cfg = loadConfig()): Promise<boolean> {
  let ok = true;
  const { contracts, beneficiary } = cfg;
  for (const chain of cfg.chains.filter((c) => c.enabled)) {
    const address = contracts?.liquidator?.[chain.id];
    if (!address) {
      log.warn({ chainId: chain.id }, 'preflight-liquidator-missing');
      ok = false;
      continue;
    }
    const client = createPublicClient({ transport: http(chain.rpc) });
    try {
      const [owner, paused, chainBeneficiary] = await Promise.all([
        client.readContract({ address, abi: LIQUIDATOR_STATE_ABI, functionName: 'owner' }),
        client.readContract({ address, abi: LIQUIDATOR_STATE_ABI, functionName: 'paused' }),
        client.readContract({ address, abi: LIQUIDATOR_STATE_ABI, functionName: 'beneficiary' }),
      ]);
      const chainOwner = owner as `0x${string}`;
      const isPaused = Boolean(paused);
      const contractBeneficiary = chainBeneficiary as `0x${string}`;
      const safeEnv = SAFE_ADDRESS_ENV[chain.id];
      const expectedOwner = safeEnv && process.env[safeEnv] ? getAddress(process.env[safeEnv] as Address) : undefined;
      if (expectedOwner && expectedOwner.toLowerCase() !== chainOwner.toLowerCase()) {
        log.warn({ chainId: chain.id, owner: chainOwner, expectedOwner }, 'preflight-liquidator-owner-mismatch');
      } else {
        log.info({ chainId: chain.id, owner: chainOwner }, 'preflight-liquidator-owner');
      }
      if (isPaused) {
        log.error({ chainId: chain.id }, 'preflight-liquidator-paused');
        ok = false;
      } else {
        log.info({ chainId: chain.id }, 'preflight-liquidator-unpaused');
      }
      if (beneficiary && beneficiary.toLowerCase() !== contractBeneficiary.toLowerCase()) {
        log.warn({ chainId: chain.id, beneficiary: contractBeneficiary, expected: beneficiary }, 'preflight-liquidator-beneficiary-mismatch');
      } else {
        log.info({ chainId: chain.id, beneficiary: contractBeneficiary }, 'preflight-liquidator-beneficiary');
      }

      for (const router of routersForChain(chain, cfg)) {
        try {
          const allowed = await client.readContract({ address, abi: LIQUIDATOR_STATE_ABI, functionName: 'allowedRouters', args: [router] });
          if (!allowed) {
            log.warn({ chainId: chain.id, router }, 'preflight-router-not-allowed');
            ok = false;
          } else {
            log.info({ chainId: chain.id, router }, 'preflight-router-allowed');
          }
        } catch (err) {
          ok = false;
          log.error({ chainId: chain.id, router, err: (err as Error).message }, 'preflight-router-check-failed');
        }
      }

      const tokens = tokensForChain(cfg, chain.id);
      for (const { symbol, info } of tokens) {
        try {
          const balance = (await client.readContract({ address: getAddress(info.address as Address), abi: ERC20_ABI, functionName: 'balanceOf', args: [address] })) as bigint;
          const formatted = formatUnits(balance, info.decimals);
          log.info({ chainId: chain.id, contract: address, token: symbol, balance: formatted }, 'preflight-liquidator-token-balance');
        } catch (err) {
          ok = false;
          log.error({ chainId: chain.id, contract: address, token: symbol, err: (err as Error).message }, 'preflight-liquidator-token-balance-failed');
        }
      }
    } catch (err) {
      ok = false;
      log.error({ chainId: chain.id, err: (err as Error).message }, 'preflight-liquidator-state-failed');
    }

    try {
      const nativeBalance = await client.getBalance({ address });
      if (nativeBalance > 0n) {
        log.info({ chainId: chain.id, contract: address, balanceEth: formatEther(nativeBalance) }, 'preflight-liquidator-native-balance');
      }
    } catch (err) {
      log.warn({ chainId: chain.id, contract: address, err: (err as Error).message }, 'preflight-liquidator-native-check-failed');
    }
  }
  return ok;
}

async function main() {
  const cfg = loadConfig();
  const results = await Promise.all([
    checkDatabase(),
    checkRedis(),
    checkRpcs(cfg),
    checkSubgraphs(cfg),
    checkQuotes(cfg),
    checkOracles(cfg),
    checkWalletBalances(cfg),
    checkContracts(cfg),
  ]);

  if (redis) {
    try {
      await redis.quit();
    } catch {}
  }
  try {
    await db.end();
  } catch {}

  const allOk = results.every(Boolean);
  if (!allOk) {
    log.error({}, 'preflight-failed');
    process.exit(1);
  }
  log.info({}, 'preflight-ok');
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});

===== END liquidator/offchain/tools/preflight.ts =====

===== BEGIN liquidator/offchain/tools/quote-check.ts =====
import '../infra/env';
import { Address, createPublicClient, getAddress, http } from 'viem';
import { loadConfig, ChainCfg } from '../infra/config';
import { log } from '../infra/logger';

const QUOTER_V2_ABI = [
  {
    name: 'quoteExactInputSingle',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [
      {
        name: 'params',
        type: 'tuple',
        components: [
          { name: 'tokenIn', type: 'address' },
          { name: 'tokenOut', type: 'address' },
          { name: 'amountIn', type: 'uint256' },
          { name: 'fee', type: 'uint24' },
          { name: 'sqrtPriceLimitX96', type: 'uint160' },
        ],
      },
    ],
    outputs: [
      { name: 'amountOut', type: 'uint256' },
      { name: 'sqrtPriceX96After', type: 'uint160' },
      { name: 'initializedTicksCrossed', type: 'uint32' },
      { name: 'gasEstimate', type: 'uint256' },
    ],
  },
];

const UNIV2_ROUTER_ABI = [
  { type: 'function', name: 'getAmountsOut', stateMutability: 'view', inputs: [
      { name: 'amountIn', type: 'uint256' },
      { name: 'path', type: 'address[]' },
    ], outputs: [{ name: 'amounts', type: 'uint256[]' }] }
];

const SOLIDLY_ROUTER_ABI = [
  { type: 'function', name: 'getAmountsOut', stateMutability: 'view', inputs: [
      { name: 'amountIn', type: 'uint256' },
      { name: 'routes', type: 'tuple[]', components: [
        { name: 'from', type: 'address' },
        { name: 'to', type: 'address' },
        { name: 'stable', type: 'bool' },
        { name: 'factory', type: 'address' },
      ] }
    ], outputs: [{ name: 'amounts', type: 'uint256[]' }] },
];

async function checkChainQuotes(chain: ChainCfg) {
  const client = createPublicClient({ transport: http(chain.rpc) });
  const tokens = chain.tokens;
  const usdc = tokens['USDC'] || tokens['USDC.e'] || tokens['USDbC'];
  const weth = tokens['WETH'] || tokens['ETH'];
  if (!usdc || !weth) {
    log.warn({ chain: chain.id }, 'missing-usdc-weth');
    return;
  }
  const usdcAddr = getAddress(usdc.address as Address);
  const wethAddr = getAddress(weth.address as Address);
  const amountIn = 1_000_000n; // 1 USDC (6dp) as a tiny probe

  // UniV3 Quoter V2 across common fee tiers
  const fees = [100, 500, 3000];
  for (const fee of fees) {
    try {
      const quoter = getAddress(chain.quoter as Address);
      const { result } = await client.simulateContract({
        address: quoter,
        abi: QUOTER_V2_ABI as any,
        functionName: 'quoteExactInputSingle',
        args: [{ tokenIn: usdcAddr, tokenOut: wethAddr, amountIn, fee, sqrtPriceLimitX96: 0n }],
        account: usdcAddr,
      });
      const amountOut = (result as any)[0] as bigint;
      log.info({ chain: chain.id, dex: 'UniV3', fee, amountIn: amountIn.toString(), amountOut: amountOut.toString() }, 'quote');
    } catch (err) {
      log.error({ chain: chain.id, dex: 'UniV3', fee, err: (err as Error).message, quoter: chain.quoter }, 'quote-error');
    }
  }

  // UniV2/Camelot
  // Try pulling from global config dexRouters map
  let uniV2Router: Address | undefined;
  let velodrome: Address | undefined;
  let veloFactory: Address | undefined;
  try {
    // Read from loaded YAML: dexRouters keyed by chain.id
    const cfg = loadConfig();
    const entry = cfg.dexRouters?.[chain.id];
    uniV2Router = entry?.camelotV2 as Address | undefined;
    velodrome = entry?.velodrome as Address | undefined;
    veloFactory = entry?.velodromeFactory as Address | undefined;
  } catch {}

  if (uniV2Router) {
    try {
      const amounts = await client.readContract({
        address: uniV2Router,
        abi: UNIV2_ROUTER_ABI as any,
        functionName: 'getAmountsOut',
  args: [amountIn, [usdcAddr, wethAddr]],
      });
      const out = (amounts as any).amounts ?? amounts;
      const last = Array.isArray(out) ? out[out.length - 1] : out;
      log.info({ chain: chain.id, dex: 'UniV2', router: uniV2Router, amountIn: amountIn.toString(), amountOut: (last as bigint).toString() }, 'quote');
    } catch (err) {
      log.error({ chain: chain.id, dex: 'UniV2', router: uniV2Router, err: (err as Error).message }, 'quote-error');
    }
  }

  if (velodrome && veloFactory) {
    try {
      const amounts = await client.readContract({
        address: velodrome,
        abi: SOLIDLY_ROUTER_ABI as any,
        functionName: 'getAmountsOut',
  args: [amountIn, [{ from: usdcAddr, to: wethAddr, stable: false, factory: veloFactory }]],
      });
      const out = (amounts as any).amounts ?? amounts;
      const last = Array.isArray(out) ? out[out.length - 1] : out;
      log.info({ chain: chain.id, dex: 'Solidly', router: velodrome, amountIn: amountIn.toString(), amountOut: (last as bigint).toString() }, 'quote');
    } catch (err) {
      log.error({ chain: chain.id, dex: 'Solidly', router: velodrome, err: (err as Error).message }, 'quote-error');
    }
  }
}

async function main() {
  const cfg = loadConfig();
  for (const chain of cfg.chains.filter((c) => c.enabled)) {
    await checkChainQuotes(chain);
  }
}

main().catch((e) => { console.error(e); process.exit(1); });

===== END liquidator/offchain/tools/quote-check.ts =====

===== BEGIN liquidator/offchain/tools/replay-candidates.ts =====
#!/usr/bin/env ts-node
import fs from 'fs';
import path from 'path';
import { createPublicClient, http } from 'viem';
import { loadConfig, chainById, liquidatorForChain } from '../infra/config';
import { executorAddressForChain } from '../infra/accounts';
import { oraclePriceUsd } from '../indexer/price_watcher';
import { simulate } from '../simulator/simulate';
import { buildRouteOptions } from '../util/routes';

import '../infra/env';

interface RawCandidate {
  borrower: `0x${string}`;
  chainId: number;
  debt: { symbol: string; address: `0x${string}`; decimals: number; amount: bigint | string | number };
  collateral: { symbol: string; address: `0x${string}`; decimals: number; amount: bigint | string | number };
}

function usage(): never {
  console.error('Usage: ts-node replay-candidates.ts <file.json> [--limit N]');
  process.exit(1);
}

function toBigInt(value: bigint | string | number): bigint {
  if (typeof value === 'bigint') return value;
  if (typeof value === 'number') return BigInt(Math.floor(value));
  if (typeof value === 'string') return value.startsWith('0x') ? BigInt(value) : BigInt(value);
  throw new Error(`unsupported amount type ${typeof value}`);
}

async function main() {
  const args = process.argv.slice(2);
  if (!args.length) usage();
  const file = path.resolve(process.cwd(), args[0]);
  const limitIndex = args.findIndex((a) => a === '--limit');
  const limit = (() => {
    if (limitIndex === -1) return undefined;
    const value = args[limitIndex + 1];
    if (!value) usage();
    const parsed = Number(value);
    if (Number.isNaN(parsed)) usage();
    return parsed;
  })();
  if (!fs.existsSync(file)) {
    console.error('File not found:', file);
    process.exit(1);
  }

  const raw = JSON.parse(fs.readFileSync(file, 'utf8')) as RawCandidate[];
  const cfg = loadConfig();
  const clients = new Map<number, ReturnType<typeof createPublicClient>>();

  let processed = 0;
  let ready = 0;
  let viable = 0;

  for (const candidate of raw) {
    if (limit !== undefined && processed >= limit) break;
    processed += 1;

    const chain = chainById(cfg, candidate.chainId);
    if (!chain) {
      console.warn('Unknown chain', candidate.chainId);
      continue;
    }
    const client = (() => {
      const cached = clients.get(chain.id);
      if (cached) return cached;
      const next = createPublicClient({ transport: http(chain.rpc) });
      clients.set(chain.id, next);
      return next;
    })();

    const debtToken = chain.tokens[candidate.debt.symbol];
    const collateralToken = chain.tokens[candidate.collateral.symbol];
    if (!debtToken || !collateralToken) {
      console.warn('Missing token metadata for candidate', candidate);
      continue;
    }

    const policy = cfg.assets[candidate.debt.symbol];
    if (!policy) {
      console.warn('Missing policy for asset', candidate.debt.symbol);
      continue;
    }

    const market = cfg.markets.find(
      (m) =>
        m.enabled &&
        m.chainId === candidate.chainId &&
        m.debtAsset === candidate.debt.symbol &&
        m.collateralAsset === candidate.collateral.symbol
    );
    if (!market) {
      console.warn('No enabled market for candidate', candidate);
      continue;
    }

    const debtPriceUsd = (await oraclePriceUsd(client, debtToken)) ?? 1;
    const collPriceUsd = (await oraclePriceUsd(client, collateralToken)) ?? debtPriceUsd;
    const contract = liquidatorForChain(cfg, chain.id);
    if (!contract) {
      console.warn('Missing liquidator address for chain', chain.id);
      continue;
    }
    if (!cfg.beneficiary) {
      console.warn('Missing beneficiary in config; cannot simulate payout target');
      continue;
    }

    const executor = executorAddressForChain(chain);
    if (!executor) {
      console.warn('Missing executor address for chain', chain.id);
      continue;
    }

    const { options } = buildRouteOptions(cfg, chain, candidate.debt.symbol, candidate.collateral.symbol);

    const plan = await simulate({
      client,
      chain,
      contract,
      beneficiary: cfg.beneficiary,
      executor,
  borrower: candidate.borrower,
      debt: { ...debtToken, symbol: candidate.debt.symbol, amount: toBigInt(candidate.debt.amount) },
      collateral: { ...collateralToken, symbol: candidate.collateral.symbol, amount: toBigInt(candidate.collateral.amount) },
      closeFactor: (market.closeFactorBps ?? 5000) / 10_000,
      bonusBps: market.bonusBps ?? 800,
      routes: options,
      pricesUsd: { debt: debtPriceUsd, coll: collPriceUsd },
      policy,
      gasCapUsd: cfg.risk.gasCapUsd,
    });

    ready += 1;
    if (!plan) continue;
    viable += 1;
    console.log(
      JSON.stringify(
        {
          borrower: candidate.borrower,
          chainId: candidate.chainId,
          repay: plan.repayAmount.toString(),
          netBps: Number(plan.estNetBps.toFixed(2)),
          router: plan.router,
          dex: plan.dexId,
        },
        null,
        2
      )
    );
  }

  console.log('\nReplay summary');
  console.log({ processed, ready, viable });
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});

===== END liquidator/offchain/tools/replay-candidates.ts =====

===== BEGIN liquidator/offchain/tools/subgraph_check.ts =====
import '../infra/env';
import { loadConfig } from '../infra/config';
import { log } from '../infra/logger';

const ENV_KEYS: Record<number, string> = {
  42161: 'AAVE_V3_SUBGRAPH_ARB',
  10: 'AAVE_V3_SUBGRAPH_OP',
  8453: 'AAVE_V3_SUBGRAPH_BASE',
  137: 'AAVE_V3_SUBGRAPH_POLYGON',
};

const FALLBACKS: Record<number, string> = {
  42161: 'https://api.thegraph.com/subgraphs/name/aave/protocol-v3-arbitrum',
  10: 'https://api.thegraph.com/subgraphs/name/aave/protocol-v3-optimism',
  8453: '',
  137: '',
};

const PING_QUERY = `
  query SubgraphMeta {
    _meta {
      block {
        number
        timestamp
      }
      deployment
    }
  }
`;

type MetaResponse = {
  _meta?: {
    block?: { number?: number; timestamp?: number };
    deployment?: string;
  };
};

function endpointFor(chainId: number): string {
  const key = ENV_KEYS[chainId];
  if (!key) return '';
  const envValue = process.env[key];
  if (envValue && !envValue.includes('<') && !envValue.includes('MISSING')) {
    return envValue;
  }
  return FALLBACKS[chainId] ?? '';
}

async function pingSubgraph(chainId: number, url: string) {
  if (!url) {
    log.warn({ chainId }, 'subgraph-missing-url');
    return;
  }

  const started = Date.now();
  try {
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({ query: PING_QUERY }),
    });

    const elapsed = Date.now() - started;
    if (!res.ok) {
      const text = await res.text();
      log.error({ chainId, url, status: res.status, body: text, elapsed }, 'subgraph-http-error');
      return;
    }

    const json = (await res.json()) as { data?: MetaResponse; errors?: unknown };
    if (json.errors) {
      log.error({ chainId, url, errors: json.errors, elapsed }, 'subgraph-graphql-error');
      return;
    }

    const meta = json.data?._meta ?? {};
    log.info(
      {
        chainId,
        url,
        block: meta.block?.number,
        timestamp: meta.block?.timestamp,
        deployment: meta.deployment,
        elapsed,
      },
      'subgraph-ok'
    );
  } catch (err) {
    log.error({ chainId, url, err: (err as Error).message }, 'subgraph-request-failed');
  }
}

async function main() {
  const cfg = loadConfig();
  const seen = new Set<number>();

  for (const market of cfg.markets.filter((m) => m.enabled)) {
    seen.add(market.chainId);
  }

  if (seen.size === 0) {
    log.warn({}, 'no-enabled-markets');
    return;
  }

  await Promise.all(Array.from(seen).map((chainId) => pingSubgraph(chainId, endpointFor(chainId))));
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
===== END liquidator/offchain/tools/subgraph_check.ts =====

===== BEGIN liquidator/offchain/tools/log_insights.js =====

===== END liquidator/offchain/tools/log_insights.js =====

===== BEGIN liquidator/offchain/tools/log_insights_watch.js =====
#!/usr/bin/env node
/*
  Watch-mode for log insights. Prints a compact summary every INTERVAL seconds.
  Env:
    LOG_PATH=/tmp/liquidator-dryrun.log (default)
    INTERVAL=30 (seconds)
*/

const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');

const LOG_PATH = process.env.LOG_PATH || '/tmp/liquidator-dryrun.log';
const INTERVAL = +(process.env.INTERVAL || 30);

function runOnce(cb) {
  const node = process.execPath;
  const script = path.resolve(__dirname, './log_insights.js');
  const p = spawn(node, [script], { stdio: ['ignore', 'pipe', 'inherit'] });
  let out = '';
  p.stdout.on('data', (d) => (out += d.toString()));
  p.on('close', (code) => {
    if (code !== 0) {
      console.error('[insights-watch] run failed with code', code);
      return cb && cb();
    }
    try {
      const json = JSON.parse(out);
      const lines = [];
      lines.push('[insights]', new Date().toISOString());
      const totalDry = (json.byMsg && json.byMsg['DRY-RUN']) || 0;
      lines.push(`DRY-RUN total: ${totalDry}`);
      for (const cs of json.chainSummaries || []) {
        lines.push(
          `chain ${cs.chain}: dry=${cs.count}, netBps p50=${cs.netBps?.p50 ?? '-'} p90=${cs.netBps?.p90 ?? '-'} max=${cs.netBps?.max ?? '-'}`
        );
      }
      if ((json.insights || []).length) {
        lines.push('tips:');
        for (const t of json.insights) lines.push(`- ${t}`);
      }
      console.log(lines.join(' '));
    } catch (e) {
      console.error('[insights-watch] parse error', e.message);
    }
    cb && cb();
  });
}

function watchLoop() {
  if (!fs.existsSync(LOG_PATH)) {
    console.error('[insights-watch] log not found', LOG_PATH);
    process.exit(2);
  }
  const tick = () => runOnce(() => setTimeout(tick, INTERVAL * 1000));
  tick();
}

if (require.main === module) watchLoop();

===== END liquidator/offchain/tools/log_insights_watch.js =====

===== BEGIN liquidator/tests/foundry/Liquidator.t.sol =====
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;
import "forge-std/Test.sol";
import "../../contracts/Liquidator.sol";

contract LiquidatorTest is Test {
    function testPlaceholder() public {
        assertTrue(true);
    }
}

===== END liquidator/tests/foundry/Liquidator.t.sol =====

===== BEGIN liquidator/tests/foundry/LiquidatorFork.t.sol =====
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import {Liquidator} from "../../contracts/Liquidator.sol";

contract LiquidatorForkTest is Test {
    Liquidator internal liquidator;
    bool internal forkActive;

    function setUp() public {
        string memory forkUrl = vm.envOr("ARB_FORK_RPC_URL", string(""));
        if (bytes(forkUrl).length == 0) {
            forkUrl = vm.envOr("FORK_RPC_URL", string(""));
        }

        if (bytes(forkUrl).length == 0) {
            forkActive = false;
            return;
        }

        forkActive = true;
        vm.createSelectFork(forkUrl);

    address pool = vm.envOr("ARB_AAVE_POOL", address(0x794a61358D6845594F94Dc1db02A252B5B481d05));
        address router = vm.envOr("ARB_UNIV3_ROUTER", address(0xE592427A0AEce92De3Edee1F18E0157C05861564));
        address beneficiary = address(0xBEEF);
        liquidator = new Liquidator(pool, router, beneficiary);
    }

    function testBeneficiarySetOnFork() public {
        if (!forkActive) return;
        assertEq(liquidator.beneficiary(), address(0xBEEF));
    }

    function testPauseAndResumeOnFork() public {
        if (!forkActive) return;
        liquidator.setPaused(true);
        assertTrue(liquidator.paused());
        liquidator.setPaused(false);
        assertFalse(liquidator.paused());
    }
}

===== END liquidator/tests/foundry/LiquidatorFork.t.sol =====

===== BEGIN liquidator/types/pg.d.ts =====
declare module 'pg';

===== END liquidator/types/pg.d.ts =====
\n===== BEGIN liquidator/offchain/infra/kill_switch.ts =====
import fs from 'fs';

const DEFAULT_INTERVAL_MS = 1_000;
const pathRaw = process.env.KILL_SWITCH_FILE?.trim();
const pollIntervalMs = Number(process.env.KILL_SWITCH_POLL_MS ?? DEFAULT_INTERVAL_MS);

let lastState = false;
let lastChecked = 0;

function refreshState(force = false): boolean {
  if (!pathRaw) {
    lastState = false;
    return lastState;
  }
  const now = Date.now();
  if (!force && now - lastChecked < pollIntervalMs) {
    return lastState;
  }
  lastChecked = now;
  try {
    lastState = fs.existsSync(pathRaw);
  } catch {
    lastState = false;
  }
  return lastState;
}

export function isKillSwitchActive(options?: { force?: boolean }): boolean {
  return refreshState(options?.force ?? false);
}

export function killSwitchPath(): string | null {
  return pathRaw && pathRaw.length > 0 ? pathRaw : null;
}
===== END liquidator/offchain/infra/kill_switch.ts =====

===== BEGIN liquidator/offchain/realtime/oracle_predictor.ts =====
type FeedStats = {
  lastTimestampMs: number;
  emaIntervalMs: number;
  samples: number;
};

const statsByFeed = new Map<string, FeedStats>();

const alpha = Number(process.env.PRECOMMIT_EMA_ALPHA ?? 0.2);
const minSamples = Number(process.env.PRECOMMIT_MIN_SAMPLES ?? 4);
const ageFactor = Number(process.env.PRECOMMIT_AGE_FACTOR ?? 0.8);
const minGapBps = Number(process.env.PRECOMMIT_MIN_GAP_BPS ?? 200);
const hfMargin = Number(process.env.PRECOMMIT_HF_MARGIN ?? 0.03);

export function recordFeedUpdate(feed: string, updatedAtMs: number | bigint): void {
  if (!feed) return;
  const normalized = feed.toLowerCase();
  let timestampMs: number;
  if (typeof updatedAtMs === 'bigint') {
    timestampMs = Number(updatedAtMs) * 1000;
  } else {
    timestampMs = updatedAtMs;
  }
  if (!Number.isFinite(timestampMs) || timestampMs <= 0) {
    timestampMs = Date.now();
  }
  const prev = statsByFeed.get(normalized);
  if (!prev) {
    statsByFeed.set(normalized, {
      lastTimestampMs: timestampMs,
      emaIntervalMs: 0,
      samples: 0,
    });
    return;
  }
  const interval = timestampMs - prev.lastTimestampMs;
  const positiveInterval = interval > 0 ? interval : 0;
  const ema = prev.emaIntervalMs === 0
    ? positiveInterval
    : (alpha * positiveInterval) + ((1 - alpha) * prev.emaIntervalMs);
  statsByFeed.set(normalized, {
    lastTimestampMs: timestampMs,
    emaIntervalMs: ema,
    samples: Math.min(prev.samples + 1, 256),
  });
}

export function shouldPrecommit(params: {
  debtFeed?: string;
  gapBps: number;
  healthFactor: number;
  hfMax: number;
}): boolean {
  const { debtFeed, gapBps, healthFactor, hfMax } = params;
  if (!debtFeed) return false;
  if (gapBps < minGapBps) return false;
  const normalized = debtFeed.toLowerCase();
  const feedStats = statsByFeed.get(normalized);
  if (!feedStats || feedStats.samples < minSamples) return false;
  if (feedStats.emaIntervalMs <= 0) return false;
  const age = Date.now() - feedStats.lastTimestampMs;
  if (age <= 0) return false;
  if (age < feedStats.emaIntervalMs * ageFactor) return false;
  if (healthFactor < hfMax) return false;
  if (healthFactor > hfMax + hfMargin) return false;
  return true;
}

export function getFeedStats(feed: string): FeedStats | undefined {
  return statsByFeed.get(feed.toLowerCase());
}

===== END liquidator/offchain/realtime/oracle_predictor.ts =====

===== BEGIN liquidator/monitoring/prometheus.yml =====
global:
  scrape_interval: 5s
  evaluation_interval: 5s

scrape_configs:
  - job_name: 'orchestrator'
    static_configs:
      - targets: ['worker:9464']

===== END liquidator/monitoring/prometheus.yml =====

===== BEGIN liquidator/monitoring/loki-config.yml =====
auth_enabled: false
server:
  http_listen_port: 3100
  http_listen_address: 0.0.0.0
  grpc_listen_port: 0
ingester:
  lifecycler:
    address: 127.0.0.1
    ring:
      kvstore:
        store: inmemory
      replication_factor: 1
  chunk_idle_period: 5m
  chunk_block_size: 262144
  chunk_retain_period: 1m
limits_config:
  ingestion_burst_size_mb: 32
  ingestion_rate_mb: 16
schema_config:
  configs:
    - from: 2020-10-24
      store: boltdb-shipper
      object_store: filesystem
      schema: v11
      index:
        prefix: index_
        period: 24h
storage_config:
  boltdb_shipper:
    shared_store: filesystem
    active_index_directory: /loki/index
    cache_location: /loki/cache
  filesystem:
    directory: /loki/chunks
chunk_store_config:
  max_look_back_period: 168h
table_manager:
  retention_deletes_enabled: true
  retention_period: 720h

===== END liquidator/monitoring/loki-config.yml =====

===== BEGIN liquidator/monitoring/promtail-config.yml =====
server:
  http_listen_port: 9080
  grpc_listen_port: 0
positions:
  filename: /tmp/positions.yaml
clients:
  - url: http://loki:3100/loki/api/v1/push
scrape_configs:
  - job_name: docker-logs
    static_configs:
      - targets: ['localhost']
        labels:
          job: orchestrator
          __path__: /var/lib/docker/containers/*/*-json.log

===== END liquidator/monitoring/promtail-config.yml =====

===== BEGIN liquidator/monitoring/grafana/provisioning/datasources/datasource.yml =====
apiVersion: 1
datasources:
  - name: Prometheus
    type: prometheus
    access: proxy
    url: http://prometheus:9090
    isDefault: true
  - name: Loki
    type: loki
    access: proxy
    url: http://loki:3100

===== END liquidator/monitoring/grafana/provisioning/datasources/datasource.yml =====

===== BEGIN liquidator/monitoring/grafana/provisioning/dashboards/dashboard.yml =====
apiVersion: 1
datasources: []
dashboardProviders:
  - name: founder
    orgId: 1
    folder: "Founder Ops"
    type: file
    disableDeletion: false
    allowUiUpdates: true
    options:
      path: /var/lib/grafana/dashboards

===== END liquidator/monitoring/grafana/provisioning/dashboards/dashboard.yml =====

===== BEGIN liquidator/monitoring/grafana/dashboards/founder.json =====
{
  "annotations": {
    "list": [
      {
        "builtIn": 1,
        "datasource": "-- Grafana --",
        "enable": true,
        "hide": true,
        "iconColor": "rgba(0, 211, 255, 1)",
        "name": "Annotations & Alerts",
        "type": "dashboard"
      }
    ]
  },
  "editable": true,
  "fiscalYearStartMonth": 0,
  "gnetId": null,
  "graphTooltip": 0,
  "id": null,
  "links": [],
  "liveNow": false,
  "panels": [
    {
      "type": "stat",
      "title": "Total Estimated Profit (USD)",
      "gridPos": { "h": 5, "w": 6, "x": 0, "y": 0 },
      "datasource": "Prometheus",
      "targets": [
        {
          "expr": "sum(profit_estimated_total_usd)",
          "legendFormat": "",
          "refId": "A"
        }
      ],
      "options": {
        "colorMode": "value",
        "graphMode": "area",
        "justifyMode": "center",
        "reduceOptions": {
          "calcs": ["lastNotNull"],
          "fields": "",
          "values": false
        }
      }
    },
    {
      "type": "gauge",
      "title": "Capture Rate",
      "gridPos": { "h": 5, "w": 6, "x": 6, "y": 0 },
      "datasource": "Prometheus",
      "targets": [
        {
          "expr": "sum(plans_sent_total) / sum(plans_ready_total)",
          "legendFormat": "",
          "refId": "A"
        }
      ],
      "options": {
        "reduceOptions": {
          "calcs": ["lastNotNull"],
          "fields": "",
          "values": false
        },
        "max": 1,
        "min": 0,
        "showThresholdLabels": false,
        "showThresholdMarkers": true,
        "thresholds": {
          "mode": "absolute",
          "steps": [
            { "color": "red", "value": 0 },
            { "color": "yellow", "value": 0.7 },
            { "color": "green", "value": 0.9 }
          ]
        }
      }
    },
    {
      "type": "timeseries",
      "title": "Profit Rate (USD/h)",
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 5 },
      "datasource": "Prometheus",
      "fieldConfig": {
        "defaults": {
          "unit": "usd"
        },
        "overrides": []
      },
      "options": {
        "legend": { "displayMode": "table", "placement": "bottom" },
        "tooltip": { "mode": "multi" }
      },
      "targets": [
        {
          "expr": "sum by (chain)(rate(profit_estimated_total_usd[5m]) * 3600)",
          "legendFormat": "{{chain}}",
          "refId": "A"
        }
      ]
    },
    {
      "type": "timeseries",
      "title": "Failure Rate",
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 13 },
      "datasource": "Prometheus",
      "fieldConfig": {
        "defaults": {
          "unit": "percentunit"
        },
        "overrides": []
      },
      "options": {
        "legend": { "displayMode": "table", "placement": "bottom" }
      },
      "targets": [
        {
          "expr": "avg_over_time(plans_failure_rate[5m])",
          "legendFormat": "{{chain}}",
          "refId": "A"
        }
      ]
    }
  ],
  "refresh": "30s",
  "schemaVersion": 39,
  "style": "dark",
  "tags": ["liquidator", "ops"],
  "templating": { "list": [] },
  "time": {
    "from": "now-6h",
    "to": "now"
  },
  "timepicker": {},
  "timezone": "",
  "title": "Founder Ops",
  "uid": "founder-ops",
  "version": 1
}

===== END liquidator/monitoring/grafana/dashboards/founder.json =====
